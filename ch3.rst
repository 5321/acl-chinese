Chapter 3 列表 (Lists)
**********************************

列表是 Lisp 中基本的資料結構之一。在最早的 Lisp 方言中，他們是唯一的資料結構： Lisp 這個名字本來代表的是 "LISt Processor" 。但 Lisp 已經超越這個縮寫很久了。 Common Lisp 是一個有著各式各樣資料結構的通用性程式語言 (general-purpose programming language)。

Lisp 程式開發通常呼應著開發 Lisp 語言自身。在最初版本的 Lisp 程式，你可能使用很多列表。然而之後的版本，你可能切換到快速、特定的資料結構。本章描述了你可以用列表所做的很多事情，以及使用它們來演示一些普遍的 Lisp 概念。

3.1 創建 (Conses)
====================

在2.4節我們介紹了 ``cons`` , ``car`` , 以及 ``cdr`` ，基本的 List 操作函數 (list-manipulation fuctions)。 ``cons`` 真正所做的事情是，把兩個物件結合成一個有兩部分的物件，稱之為 *Cons* 物件。概念上來說，一個 cons 是一對指標; 第一個是 car ，第二個是 cdr。

Cons 物件提供了一個方便的表示法來表示任何型態的物件。一個 Cons 物件裡的一對指標可以指向任何種類的物件，包括 Cons 物件本身。它利用到我們之後可以用 ``cons`` 來創建列表的可能性。

我們往往不會把列表想成是成對的，但它們可以這樣被定義。任何非空的列表，都可以被視為一對由列表第一個元素及列表其餘元素所組成的列表。 Lisp 列表體現了這個概念。我們使用 cons 的一半 (car)來指向列表的第一個元素，然後用另一半 (cdr)指向列表其餘的元素 (可能是別的 Cons 物件或 nil)。 Lisp 的慣例是使用 ``car`` 代表列表的第一個元素，而用 ``cdr`` 代表列表的其餘的元素。所以現在 ``car`` 是列表的第一個元素的同義詞，而 ``cdr`` 是列表的其餘的元素的同義詞。列表不是不同的物件，而是像 Cons 這樣的方式連結起來。

當我們想在 ``NIL`` 上面建立東西時，

::

   > (setf x (cons 'a nil))
   (A)

\

.. figure:: https://dl-web.dropbox.com/get/Juanito/acl-images/Figure-3.1.png?w=903fbe8f
    
圖 3.1 一個元素的列表

產生的列表由一個 Cons 所組成，見圖3.1。這種表達 Cons 的方式叫做 箱子標示法 (box notation)，因為每一個 Cons 是用一個箱子表示，內含一個 ``car`` 和 ``cdr`` 的指標。當我們呼叫 ``car`` 與 ``cdr`` 時，我們得到指標指向的地方：

::
   
   > (car x)
   A
   > (cdr x)
   NIL

當我們創建一個多元素的列表時，我們得到一串 Conses (a chain of conses)：

::

   > (setf y (list 'a 'b 'c))
   (A B C)

產生的結構見圖3.2。現在當我們想得到這個列表的 ``cdr`` 時，它是一個兩個元素的列表。

\

.. figure:: https://dl-web.dropbox.com/get/Juanito/acl-images/Figure-3.2.png?w=b42e4db9
   
圖 3.2 三個元素的列表

::

   > (cdr y)
   (B C)

在一個有多個元素的列表中， ``car`` 指標讓你取得元素，而 ``cdr`` 讓你取得列表內其餘的東西。

一個列表可以有任何種類的物件作為元素，包括另一個列表：

::

   > (setf z (list 'a (list 'b 'c) 'd'))
   (A (B C) D)

當這種情況發生時，它的結構如圖3.3所示; 第二個 Cons 的 ``car`` 指標也指向一個列表：

::

  > (car (cdr z))
  (B C)

\

.. figure:: https://dl-web.dropbox.com/get/Juanito/acl-images/Figure-3.3.png?w=10d193e0
    
圖 3.3 巢狀列表


前兩個我們創建的列表都有三個元素; 只不過 ``z`` 列表的第二個元素也剛好是一個列表。像這樣的列表稱為 *巢狀* 列表，而像 ``y`` 這樣的列表稱之為 *平坦* 列表 ( *flat* list)。

如果引數是一個 Cons 物件，函數 ``consp`` 回傳真。所以我們可以這樣定義 ``listp`` ：

::

  (defun our-listp (x)
  	(or (null x) (consp x)))

因為所有不是 Cons 物件的東西就是一個原子 (atom)，判斷式 ``atom`` 可以這樣定義：

::

   (defun our-atom (x) (not (consp x)))

注意， ``NIL`` 是一個原子，同時也是一個列表。

3.2 等式 (Equality)
=====================

每一次你呼叫 ``cons`` 時， Lisp 會分配一塊新的記憶體給兩個指標。所以如果我們用同樣的引數呼叫 ``cons`` 兩次，我們得到兩個數值看起來一樣，但實際上是兩個不同的物件：

::

   > (eql (cons 'a nil) (cons 'a nil))
   NIL

如果我們也可以詢問兩個列表是否有相同元素，那就很方便了。 Common Lisp 提供了這種目的另一個判斷式： ``equal`` 。而另一方面 ``eql`` 只有在它的引數是相同物件時才回傳真，

::

   > (setf x (cons 'a nil))
   (A)
   > (eql x x)
   T
  
本質上 ``equal`` 若它的引數列印出的值相同時，回傳真：

::

   > (equal x (cons 'a nil))
   T

這個判斷式對非列表結構的別種物件也有效，但一種僅對列表有效的版本可以這樣定義：

::

   > (defun our-equal (x y)
       (or (eql x y)
           (and (consp x)
                (consp y)
                (our-equal (car x) (car y))
                (our-equal (cdr x) (cdr y)))))

這個定義意味著，如果某個 x 和 y 相等 ( ``eql`` )，那麼他們也相等 ( ``equal`` )。

3.3 為什麼Lisp沒有指標 (Why Lisp Has No Pointers)
=======================================================

一個理解 Lisp 的祕密之一是意識到變數是有值的，就像列表有元素一樣。如同 Conses 物件有指標指向他們的元素，變數有指標指向他們的值。

你可能在別的語言中使用過顯示指標 (explicitly pointer)。在 Lisp ，你永遠不用這麼做，因為語言幫你處理好指標了。我們已經在列表看過這是怎麼達成的。同樣的事情發生在變數身上。舉例來說，假設我們想要把兩個變數設成同樣的列表：

::

   > (setf x '(a b c))
   (A B C)
   > (setf y x)
   (A B C)

.. figure:: https://dl-web.dropbox.com/get/Juanito/acl-images/Figure-3.4.png?w=72840b32
    
圖3.4 兩個變數設為相同的列表

當我們把 x 的值賦給 y 時，究竟發生什麼事呢？記憶體中與 x 有關的位置並沒有包含這個列表，而是一個指標指向它。當我們給 y 賦一個相同的值時， Lisp 複製的是指標，而不是列表。（圖 3.4 顯示賦值 x 給 y 後的結果）所以無論何時你把一個變數賦給另一個變數時，兩個變數會有 ``eql`` 的值。

::

   > (eql x y)
   T

Lisp 沒有指標的原因是因為每一個值，其實概念上來說都是一個指標。當你賦一個值給變數或將這個值存在資料結構中，其實被儲存的是指向這個值的指標。當你要取得變數的值，或是存在資料結構中的內容時， Lisp 回傳指向這個值的指標。但這都在檯面下發生。你可以不加思索地把值放在結構裡，或放 "在" 變數裡。

為了效率的原因， Lisp 有時會選擇一個折衷的表示法，而不是指標。舉例來說，因為一個小整數所需的記憶體空間，少於一個指標所需的空間，一個 Lisp 實現可能會直接處理這個小整數，而不是用指標來處理。但基本要點是，程式設計師，預設上，你可以把任何東西放在任何地方。除非你宣告你不願這麼做，不然你能夠在任何的資料結構，存放任何種類的物件，包括結構本身。

3.4 建立列表 (Building Lists)
=================================

.. figure:: https://dl-web.dropbox.com/get/Juanito/acl-images/Figure-3.5.png?w=d1e830b3

圖 3.5 複製的結果

函數 ``copy-list`` 接受一個列表，然後返回此列表的副本。新的列表會有同樣的元素，但是裝在新的 Conses 物件裡：

::

   > (setf x '(a b c))
           y (copy-list x))
   (A B C)

圖 3.5 顯示出結果的結構; 回傳值像是有著相同乘客的新公車。我們可以把 ``copy-list`` 想成是這麼定義的:

::

   (defun our-copy-list (lst)
     (if (atom list)
         lst
         (cons (car lst) (our-copy-list (cdr lst)))))

這個定義暗示著 x 與 (copy-list x) 會永遠 ``equal`` ，並永遠不  ``eql`` ，除非 x 是 ``NIL`` 。

最後，函數 ``append`` 回傳任何數目的列表串接 (concatenation)：

::

   > (append '(a b) '(c d) 'e)
   (A B C D E)

通過這麼做，它複製所有的引數，除了最後一個。

3.5 範例：壓縮 (Example: Compression)
============================================

3.6 存取 (Access)
======================

3.7 映對函數 (Mapping Functions)
============================================

3.8 樹 (Trees)
======================

3.9 理解遞迴 (Understanding Recursion)
============================================

3.10 集合 (Sets)
======================

3.11 序列 (Sequences)
=================================

3.12 堆疊 (Stacks)
=================================

3.13 點列表 (Dotted Lists)
=================================

3.14 關連列表 (Assoc-lists)
===================================

3.15 範例：最短路徑 (Example: Shortest Path)
==================================================

3.16 垃圾 (Garbages)
=========================

Chapter 3 總結 (Summary)
================================ 

Chapter 3 練習 (Exercises)
==================================