.. highlight:: cl
   :linenothreshold: 0

Chapter 13 速度 (Speed)
**************************************************
Lisp真的是两种语言：一种能写出快速执行的程序，一种则能让你快速的写出程序。
在程序开发的早期阶段，你可以为了开发上的便捷舍弃程序的执行速度。
一旦程序的结构开始固化 (crystallize)，你就可以精炼其中的关键部分以使得它们执行的更快。

由于各个Common Lisp实现 (implementation) 间的差异，很难针对优化 (optimization) 给出通用的建议。
在一个实现上使程序变快的变更也许在另一个实现上会使得程序变慢。
This is something that comes with the territory.
越强大的语言，离机器底层就越远，离机器底层越远，语言的不同实现沿着不同路径趋向它的可能性就越大。
因此，即便有一些技巧几乎一定能够让程序运行的更快，本章的目的也只是建议而不是指示 (prescribe)。

13.1 瓶颈规则 (The Bottleneck Rule)
==================================
不管实现如何，关于优化可以整理出三点规则：它应该关注瓶颈，它不应该开始的太早，它应该始于算法。

也许关于优化最重要的事情就是要认识到程序执行中相当大的一部分时间都是由少数的瓶颈引起的。
根据Knuth, “在一个与I/O无关 (Non-I/O bound) 的程序中大部分的运行时间集中在大概3%的源代码中”。
优化程序的这一部分将会使得它的运行速度明显的提升；相反，优化程序的其他部分将是在浪费时间。

因此，优化程序的关键的第一步就是找到瓶颈。
许多Lisp实现都提供profiler来监视程序的运行并报告每一部分所花费的时间量。
profiler是非常重要的 -- 甚至是必不可少的 -- 生产最为高效代码的有力工具。
如果你的Lisp实现提供了一个，使用它来指引你完成优化吧。如果没有，你不得不通过猜测来寻找瓶颈。
但也许你会惊异的发现猜不中的机会是那么的高！

瓶颈规则的一个推论是你不应该在程序的早期花费太多的精力在优化上。Knuth对此甚至更加深信不疑：“
过早的优化是一切(至少是大多数)问题的源头”。
在你刚开始写程序的时候很难看清它真正的瓶颈在哪，因此，如果这个时候进行优化，你很可能是在浪费时间。
优化也容易使的程序变更变得更加困难，试图边写程序边优化就像是试图用干的太快的颜料来作画。

在合适的时间集中精力搞好该做的事情将会让你写出更优秀的程序。
Lisp的一个优点就是能让你用不同的速度工作：很快的写出运行速度较慢代码或慢慢的写运行速度较快的代码。
在程序开发的早期阶段，你趋向工作在前一种模式下，然后当优化摆在眼前时，你切换到后一种模式工作。
对于非常底层的语言，如汇编，你必须优化程序的每一行。但这么做会浪费你大部分的精力，因为瓶颈仅仅是其中很小的那部分代码。
一个更加抽象的语言能够让你把主要精力集中在瓶颈上， 达到事半功倍的效果。

当你真的面对优化时，还要从最顶端入手。
在开始采用各种低阶的编码技巧 (low-level coding tricks) 前先确保你已经使用了最为高效的算法。
这么做潜在的好处相当大--甚至可能大到你都不再需要玩那些奇淫技巧。
当然本规则还是要和前一个规则保持平衡。有些时候必须在早期决定使用的算法。

13.2 编译 (Compilation)
==================================================
有五个参数 (parameter) 可以控制代码的编译： *speed* (速度) 代表编译器产生代码的速度；
*compilation-speed* (编译速度) 代表程序被编译的速度； *safety* (安全) 代表目标代码中进行错误检查的数量；
*space* (空间) 代表目标代码的大小和内存需求量；最后， *debug* (调试) 代表为了调试而保留的信息量。

::

   交互 与 解释 (INTERACTIVE VS. INTERPRETED)

   Lisp是一种交互式语言 (Interactive Language), 但是交互式的语言不必都是解释型(Interpreted)的。
   早期的Lisp都通过解释器实现， 因此认为Lisp的特质都依赖与它是被解释的想法就这么产生了。但这种
   想法是错误的：Common Lisp即是编译型又是解释型的语言。

   至少有两种Common Lisp实现甚至都不包含解释器 (interpreter)。在这些实现中，输入到顶层(toplevel)的表达式
   在求值前被编译。因此，把顶层叫做解释器的不光是落伍的说法，甚至是错误的说法。

编译参数 (compilation parameter) 不是真正的变量。它们在声明中被分配从0 (最不重要) 到3 (最重要) 的权值 (weight)。
如果一个主要的瓶颈发生在某个函数的内层循环 (inner loop) 中，我们或许可以添加如下的声明：
::
   (defun bottleneck (...)
     (do (...)
         (...)
        (do (...)
            (...)
           (declare (optimize (speed 3) (safety 0)))
           ...)))
一般来讲你不会愿意在代码写完和测试通过前就加上这么一句声明。

你也可以不管不顾的在全局要求所有的代码都尽可能的快，如下：
::
   (declaim (optimize (speed 3)
                      (compilation-speed 0)
                      (safety 0)
                      (debug 0)))
这么做是相当极端的，考虑到瓶颈规则 [1]_ 甚至恐怕没有必要这么做。

.. [1] 较早的实现或许不提供 *declaim* ；需要使用 *proclaim* 并且引用这些参量 (quote the argument)。

另一类特别重要的优化就是由Lisp编译器完成的尾调用优化 (the optimization of tail calls)。
当 *speed* (速度) 的权值最大时所有支持尾调用优化的编译器都将保证对代码进行这种优化。

如果在一个调用返回时调用者中没有残余的计算，该调用就被称为尾调用。下面的代码返回列表 (list) 的长度：
::
   (defun length/r (lst)
      (if (null lst)
         0
         (1+ (length/r (cdr lst)))))
这个递归调用不是尾调用，因为当它返回以后，它的值必须传给 *1+* 。相反，这是一个尾递归的版本，
::
   (defun length/rt (lst)
      (labels ((len (lst acc)
                 (if (null lst)
                     acc
                     (len (cdr lst) (1+ acc)))))
        (len lst 0)))
或者更准确的说，局部函数 (local function) *len* 是尾递归调用，因为在递归调用返回时没有什么其他
的事情发生了。和 *length/r* 不同的是，它不是在递归回溯的时候构建返回值而是在递归调用的过程中积累返回值。
所以额外的 *acc* 参数，在最后一层递归调用结束后就可以简单的返回。

出色的编译器可以将一个尾调用编译成一个 *goto* ，因此可以将一个尾递归函数编译成一个 *loop* 。在典型的机器语言代码中 (machine language code)，
当第一次执行到表示len的指令片段 (the segment of instructions) 时，栈上会有信息指示在返回时该怎么做。
由于在尾递归调用后没有残余的计算，这个信息对于第二次调用仍然是有效的：我们从第二次调用返回后需要做的仅仅就是从第一次调用返回。
因此，在赋予参数新的值后我们就可以跳到函数的开头，然后就像进行第二次调用一样动作。但实际上没有函数调用发生。

另一个利用函数调用抽象 (abstraction of function calls) 而又没有开销的方法是使函数内联编译 (compiled inline)。
针对调用开销比函数体的执行代价还高的小型函数来说这非常有价值。例如，下面的代码判断是否是仅含有一个元素的列表：
::
   (declaim (inline single?))
   (defun single? (lst)
      (and (consp lst) (null (cdr lst))))
因为这个函数是在全局被声明为内联的，引用了 *single?* 的函数在编译后将不需要真正的函数调用。 [2]_ 如果我们定义一个调用它的函数,
::
   (defun foo (x)
     (single? (bar x)))
当 *foo* 被编译后， *single?* 函数体中的代码将会被编译进 *foo* 的函数体，就好像我们直接写：
::
   (defun foo (x)
     (let ((lst (bar x)))
       (and (consp lst) (null (cdr lst)))))

.. [2] 为了让内联声明(inline declaration)有效，你同时必须设置编译参数，告诉它你想获得最快的代码。

内联编译 (inline compilation) 有两个限制。递归函数不能内联。另外如果一个内联函数被重新定义，我们就必须
重新编译调用它的任何函数，否则调用仍然使用原先的定义。

在一些早期Lisp方言中，有些使用宏 (macros) (Section 10.2) 来避免函数调用。通常认为在Common Lisp中这么做是没有必要的。

不同的Lisp编译器做的优化也千差万别。如果你想了解你的编译器为某个函数生成的代码，试着调用 *disassemble* 。
该函数接受一个函数或者函数名并显示它编译后的形式 (compiled form)。即便你看到的东西是完全无法理解的，
你仍然可以使用 *disassemble* 来判断声明是否起效果：编译函数的两个版本，一个使用声明一个不使用，
然后观察由 *disassemble* 显示的两组代码之间是否有差异。你也可以用类似的技巧来查看函数是否被内联编译了。
不管那种情况，确保事先设置编译参数来获得最快的代码。
   

13.3 类型声明 (Type Declarations)
================================
如果Lisp是你所学的第二门编程语言，你也许会感到困惑我们为何还未谈及类型声明这件事儿，
毕竟它在其他一些编程语言中是那样盛行且必要。

在大多数编程语言中，你必须为每个变量声明类型，并且变量也只可以有与之类型相一致的值。
这种语言被称为 *强类型* ( *strongly typed* ) 的。除了给程序员们徒增了许多负重外，这种
方式还限制了你能做的事情。使用这种语言，很难写出可以和不同种类的参数一起工作的函数，也
很难定义出可以包含不同种类元素的数据结构。当然，这种方式也有它的优势，比如无论何时当编译
器碰到一个加法运算，它都能够事先知道这是一个什么类型的加法运算。如果两个参量都是整数类型，
编译器可以直接在目标代码中生成一个固定 (hard-wire) 的整数加法运算。

正如 2.15 节讲的那样，Common Lisp 使用一种更加灵活的方式：显示类型 (manifest typing) [3]_ 。
有类型的是值而不是变量。变量可以用于任何类型的对象。

.. [3] 有两种方法可以描述Lisp声明类型 (typing) 的方式：从类型信息被存放的位置或者从它被使用的时间。
       显示类型 (manifest typing) 的意思是类型信息与数据对象 (data objects) 绑定，而运行时类型
       (run-time typing) 的意思是类型信息在运行时被使用。实际上，两者是一回事儿。

如果我们仅仅如此，就不得不为了灵活性牺牲速度。由于 *+* 可以接受好几种不同类型的数，它不得不
在运行时查看每个参量的类型来决定采用哪种加法运算。

如果我们只是想要一个整数加法运算，这将是一种低效的方法。Common Lisp 的方式是：把你所知道的尽可能都告诉我。
如果我们提前就能知道某个加法运算的两个参数是定数 (fixnums)，我们就可以对此进行声明，
这样编译器就会像C语言的那样为我们生成一个固定的整数加法运算。

因此，这两种声明类型 (typing) 的方式不会在运行速度上有什么差别。区别仅仅是在第一种方式中
类型声明是强制性的，而第二种则不对你强加这样的要求。在 Common Lisp 中类型声明完全是可选的。
它们可以让程序运行的更快，但(除非错误)不会改变程序的行为。

全局声明 (global declarations) 通过 *declaim* 和其后的一个或多个声明形式 (declaration forms) 实现。
一个类型声明由包含了符号 (symbol) *type* ，紧接其后的一个类型名 (type name) 以及后面一个或多变量的
列表 (list)构成。因此，如果要声明一个全局变量的类型，你可以这么写：
::
   (declaim (type fixnum *count*))
在 ANSI Common Lisp 中，你可以省略 *type* 简写为：
::
   (declaim (fixnum *count*))

局部声明 (local declarations) 可以通过 *declare* 完成，其后参数与 *declaim* 的相同。声明可以在任何
变量刚刚被创建出来的代码体前进行：如 *defun* ， *lambda* ， *let* ， *do* 等等。例如，要把一个函数
的参数声明为定数，我们可以这么写：
::
   (defun poly (a b x)
      (declare (fixnum a b x))
      (+ (* a (expt x 2)) (* b x)))
在类型声明中的变量名指的就是该声明所在的上下文中的那个变量 -- 那个通过赋值可以改变它的值的变量。

你也可以通过 *the* 为某个表达式的值声明类型。如果我们提前就知道 *a* ， *b* 和 *x* 它们不仅仅是定数，
而且是它们小的以至于相互运算的中间结果也都是定数的话，我们可以这么写：
::
   (defun poly (a b x)
      (declare (fixnum a b x))
      (the fixnum (+ (the fixnum (* a (the fixnum (expt x 2))))
                     (the fixnum (* b x)))))
看起来是不是很笨拙啊？幸运的是有两个原因让你很少会这样使用 *the* 把你的数值运算代码变得散乱不堪。
其一是很容易通过宏 (macaros) 来帮你插入这些声明。其二是某些实现使用了特殊的技巧让即便没有类型声明
的定数运算也足够快。

Common Lisp 中有相当多的类型--恐怕有无数种类型那么多，如果考虑到你可以自己定义新的类型的话。但声明
只在少数情况下至关重要，什么时候值得去做类型声明呢？我们可以遵照一下两条规则：

   1. 当函数可以接受若干不同类型的参数(但不是所有类型)时，可以对参数的类型进行声明。如果你知道一个
      对 *+* 的调用总是接受定数类型的参数，或者一个对 *aref* 的调用第一个参数总是某种特定种类的数组 (array)
      ，那么进行类型声明是值得的。


   2. 通常只有对类型层级 (type hierarchy) 中接近底层的类型进行声明是值得的：将某个东西的类型声明为
      *fixnum* 或者 *simple-array* 也许有用，但将某个东西的类型声明为 *integer* 或者 *sequence* 或许就没用。

类型声明对内容复杂的对象特别重要，这包括数组 (arrays)、结构 (structures) 和实例 (instances)。
这些声明可以在两个方面提升效率：除了可以让编译器来决定函数参数的类型以外，它们也使得在内存中用更为高效的方
式表示这些对象成为可能。

如果对数组元素的类型一无所知的话，这些元素在内存中就不得不用一组指针 (a block of pointers) 来表示。
但假如预先就知道数组包含的元素仅仅是 -- 比方说 -- 双精度浮点数 (double-floats)，那么这个数组就可以用一组实际的
双精度浮点数来表示。这样数组将占用更少的空间，因为我们不再需要额外的指针指向每一个双精度浮点数；同时，
对数组元素的访问也将更快，因为我们不必沿着指针去读取和写元素。

你可以通过 *make-array* 的 *:element-type* 参数指定数组包含值的种类。这样的数组被称为 *特化数组* (specialized array)。
图 13.1 为我们展示了在多数实现上如下代码求值后发生的事情：
::
   (setf x (vector 1.234d0 2.345d0 3.456d0)
         y (make-array 3 :element-type 'double-float)
         (aref y 0) 1.234d0
         (aref y 1) 2.345d0
         (aref y 2）3.456d0))

图 13.1 中的每一个矩形方格代表内存中的一个字 (a word of memory)。这两个数组都由未特别指明长度的头部 (header) 以及后续
三个元素的某种表示构成。对于 *x* 来说，每个元素都由一个指针表示。此时每个指针碰巧都指向双精度浮点数，但实际上
我们可以存储任何类型的对象到这个向量 (vector) 中。对 *y* 来说，每个元素实际上都是双精度浮点数。 *y* 更快而且占用更少
空间，但意味着它的元素只能是双精度浮点数。

注意我们使用 *aref* 来引用 *y* 的元素。一个特化的向量不再是一个简单向量 (simple vector)，因此我们不再能够通过 *svref*
来引用它的元素。

除了在创建数组时指定元素的类型，你还应该在使用数组的代码中声明数组的维度 (dimensions) 以及它的元素类型。
一个完整的向量声明如下：
::
   (declare (type (vector fixnum 20) v))
声明一个仅含有定数的长度固定为20的向量。

最为通用的数组声明形式由数组类型以及紧接其后的元素类型和一个维度列表构成：
::
   (declare (type (simple-array fixnum (4 4)) ar))
图 13.2 展示了如何创建一个 1000*1000 的单精度浮点数数组，以及如何写一个将该数组元素相加的函数。
数组以行主序 (row-major order)存储，在遍历时也应尽可能以此序进行。

我们将用 *time* 来比较 *sum-elts* 在有声明和无声明两种情况下的性能。 
*time* 宏显示表达式求值所花费时间的某种度量(some measure) (依赖于实现)。对被编译的函数求取时间才是有意义的。
在某个实现中，如果我们以获取最快速代码的编译参数编译 *sum-elts* ，它将在不到半秒的时间内返回：
::
   > (time (sum-elts a))
   User Run Time = 0.43 seconds
   1000000.0
如果我们把 *sum-elts* 中的类型声明去掉并重新编译它，同样的计算将花费超过5秒的时间：
::
   > (time (sum-elts a))
   User Run Time = 5.17 seconds
   1000000.0

类型声明的重要性 -- 特别是对数组和数来说 -- 怎么强调都不过分。这里，仅仅两行代码就可以让 *sum-elts* 变快 12 倍。

13.4 避免垃圾 (Garbage Avoidance)
===================================================
就像Lisp允许你推后对变量类型的考虑一样，它也允许你推后对内存分配 (memory allocation) 的考虑。在程序的早期阶段
不用去考虑内存分配 (或者棘手的bug ) 将解放你的想象力。当程序成熟时，它可以依赖更少的动态分配从而变得更快。

然而，较少的构建 (consing) 并不总是让程序更快。对于那些依赖着低端 (bad) 垃圾回收器 (garbage collector) 的Lisp实现来说，过多的
构建 (cons) 容易让程序运行缓慢。多数Lisp实现一直都还使用着低端垃圾回收器，因此高效的程序应尽可能少的构建就变成了一种
传统。最近的发展完全改变了这种传统观点。一些实现上现在已经拥有了相当先进 (sophisticated) 的垃圾回收器，它构建新对象然后
抛弃它们而不是回收这些对象，这样就会更高效。

本节介绍几种让程序构建更少的方法。 但是否构建少了就能让你的程序运行的更快还依赖于实现。最佳忠告依然是自己去试一下吧。
为了减少构建你需要做很多事。有些是不会改变你程序的形状的。例如，其中最简单的就是使用解构函数 (destructive function)。
下表中罗列一些常用的函数以及与它们对应的解构版本。

|-------------------+-------------------|
|      SAFE         |   DESTRUCTIVE     |
| append            | nconc             |
| reverse           | nreverse          |
| remove            | delete            |
| remove-if         | delete-if         |
| remove-duplicates | delete-duplicates |
| subst             | nsubst            |
| subst-if          | nsubst-if         |
| union             | nunion            |
| intersection      | nintersection     |
| set-difference    | nset-difference   |
|-------------------+-------------------|
当你知道修改一个列表是安全的时候，你可以使用 *delete* 替换 *remove* ， *nreverse* 替换 *reverse 等等。

即便你想完全摆脱构建，你也不必放弃在运行中 (on the fly) 创建对象的可能性。
你需要避免的是在运行中 (on the fly) 为它们分配空间和通过垃圾回收来收回空间。通用方案是你自己预先分配内存块
(block of memory)，以及明确回收用过的块。 *预先* 可能意味着在编译期或者某些初始化例程 （routine) 中。具体情况
还应具体分析 (When speed begins to matter depends on the application) 。

例如，当情况允许我们利用一个有限大小的堆栈时，我们可以让堆栈在一个已经分配了的向量中增长或缩减，而不是构建
它。Common Lisp内建支持把向量作为堆栈使用。如果我们传给 *make-array* 可选的 *fill-pointer* 参数，
我们将得到一个看起来可以扩展 (expendable) 的向量。 *make-array* 的第一个参数指定了分配给向量的存储量，而
*fill-pointer*指定了初始有效长度：
::
   > (setf *print-array* t)
   T
   > (setf vec (make-array 10 :fill-pointer 2
                              :initial-element nil))
   #(NIL NIL)
我们刚刚制造的向量对于序列函数 (sequence function) 来说仍好像只含有两个元素，
::
   > (length vec)
   2
但它能够增长直到十个元素。因为 *vec* 有一个填充指针 (fill pointer)，我们可以使用 *vector-push* 和 *vector-pop*
函数推入和弹出元素，就像它是一个列表一样：
::
   > (vector-push 'a vec)
   2
   > vec
   #(NIL NIL A)
   > (vector-pop vec)
   A
   > vec
   #(NIL NIL)
当我们调用 *vector-push* 时，它增加填充指针并返回它过去的值。只要填充指针小于 *make-array* 的第一个参数，我们
就可以向这个向量中压入 (push) 新元素；当空间用尽时， *vector-push* 返回 *nil* 。目前我们还可以向 *vec* 中
压入八个元素。
使用带有填充指针的向量有一个缺点，就是它们不再是简单向量 (simple vector)。我们不得不使用 *aref* 来代替 *svref*
引用元素。代价需要和潜在的收益保持平衡。










13.5 示例: 池 (Example: Pools)
=======================================

13.6 快速操作符 (Fast Operators)
=======================================

13.7 二阶段开发 (Two-Phase Development)
==================================================

Chapter 13 总结 (Summary)
============================

Chapter 13 练习 (Exercises)
==================================
