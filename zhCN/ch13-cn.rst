.. highlight:: cl
   :linenothreshold: 0

Chapter 13 速度 (Speed)
**************************************************
Lisp真的是两种语言：一种能写出快速执行的程序，一种则能让你快速的写出程序。
在程序开发的早期阶段，你可以为了开发上的便捷舍弃程序的执行速度。
一旦程序的结构开始固化（crystallize)，你就可以精炼其中的关键部分以使得它们执行的更快。

由于各个Common Lisp实现(implementation)间的差异，很难针对优化(optimization)给出通用的建议。
在一个实现(implementation)上使程序变快的变更也许在另一个实现(implementation)上会使得程序变慢。
This is something that comes with the territory.
越强大的语言，离机器底层就越远，离机器底层越远，语言的不同实现沿着不同路径趋向它的可能性就越大。
因此，即便有一些技巧几乎一定能够让程序运行的更快，本章的目的也只是建议而不是指示(prescribe)。

13.1 瓶颈规则 (The Bottleneck Rule)
==================================
不管实现如何，关于优化可以整理成三点：它应该关注瓶颈，它不应该开始的太早，它应该始于算法。

也许关于优化最重要的事情就是要认识到程序执行时间中的相当大一部分都是由少数的瓶颈引起的。
根据Knuth, “在一个与I/O无关(Non-IO bound)的程序中大部分的运行时间集中在大概3%的源代码中”。
优化程序的这部分将会使得它的运行速度明显的提升；相反，优化程序的其他部分将是在浪费时间。

因此，优化程序的关键的第一步就是找到瓶颈。
许多Lisp实现都提供profiler来监视程序的运行并报告每一部分所花费的时间量。
profiler是非常重要的--甚至是必不可少的--生产最为高效代码的有力工具。
如果你的Lisp实现提供了一个，使用它来指引你完成优化吧。如果没有，你不得不通过猜测来寻找瓶颈。
但也许你会惊异的发现猜不中的机会是那么的高！

瓶颈规则的一个推论是你不应该在程序的早期花费太多的精力在优化上。Knuth对此甚至更加深信不疑：“
过早的优化是一切（至少是大多数）问题的源头”。
在你刚开始写程序的时候很难看清它真正的瓶颈在哪，因此，如果这个时候进行优化，你很可能是在浪费时间。
优化也容易使的程序变更变得更加困难，试图边写程序边优化就像是试图用干的太快的颜料来作画。

在合适的时间集中精力搞好该做的事情将会让你写出更优秀的程序。
Lisp的一个优点就是能让你用不同的速度工作：快速的写运行较慢代码或慢慢的写运行快速的代码。
在程序开发的早期阶段，你趋向工作在前一种模式下，然后当优化摆在眼前时，你切换到后一种模式工作。
对于非常底层的语言，如汇编，你必须优化程序的每一行。但大部分的精力其实都浪费掉了，因为瓶颈仅仅是其中很小的那一部分代码。
一个更加抽象的语言让你能够把主要精力集中在瓶颈上， 达到事半功倍的效果。

当你真的面对优化时，要从最顶端入手。
在开始采用各种低阶的编码技巧(low-level coding tricks)前先确保你已经使用了最为高效的算法。
这么做潜在的好处相当大--甚至大到你都不再需要玩那些奇淫技巧。
当然本规则还是要和前一个规则保持平衡。有些时候必须在早期决定使用的算法。

13.2 编译 (Compilation)
==================================================
有五个参数(parameter)可以控制代码的编译：速度(speed)代表编译器产生代码的速度；
编译速度(compilation-speed)代表程序被编译的速度；安全(safety)代表目标代码中进行错误检查的数量；
空间(space)代表目标代码的大小和内存需求量；最后，调试(debug)代表为了调试而保留的信息量。

::
   交互 与 解释 (INTERACTIVE VS. INTERPRETED)

   Lisp是一种交互式语言(Interactive Language), 但是交互式的语言不必都是解释型(Interpreted)的。
   早期的Lisp都通过解释器实现的， 认为Lisp的特质都依赖与它是被解释的想法就这么产生了。但这种
   想法是错误的：Common Lisp即是编译型又是解释型的语言。

   至少有两种Common Lisp实现甚至都不包含解释器(interpreter)。在这些实现中，输入到顶层(toplevel)的表达式
   在求值前被编译。因此，把顶层(toplevel)叫做解释器(interpreter)的说法不光是落伍了，甚至本身就是错误的。

编译参数(compilation parameter)不是真正的变量。它们在声明中被分配从0（最不重要）到3（最重要）的权值(weight)。
如果一个主要的瓶颈发生在某个函数的内层循环(inner loop)中，我们或许可以添加如下的声明::
   (defun bottleneck (...)
     (do (...)
         (...)
        (do (...)
            (...)
           (declare (optimize (speed 3) (safety 0)))
           ...)))
一般来讲你不会愿意在代码写完和测试通过前就加上这么一句声明。

你也可以不管不顾的在全局要求所有的代码都尽可能快，如下::
   (declaim (optimize (speed 3)
                      (compilation-speed 0)
                      (safety 0)
                      (debug 0)))
这么做是相当极端的，考虑到瓶颈规则[1]_或许甚至是没有必要的。

.. [1] 较早的实现或许不提供declaim；需要使用proclaim并且引用这些参量(quote the argument)。

另一类特别重要的优化就是由Lisp编译器完成的尾调用优化(the optimization of tail calls)。
当速度(speed)的权值最大时所有能够支持尾调用优化的编译器都将保证尾调用优化的达成。

一个调用如果当它返回时调用者中没有残余的计算时，它被称为尾调用。下面的代码返回列表(list)的长度::
    (defun length/r (lst)
      (if (null lst)
          0
          (1+ (length/r (cdr lst)))))
这个递归调用不是尾调用，因为当它返回以后，它的值必须传给1+。相反，这个版本是一个尾递归，
::
   (defun length/rt (lst)
      (labels ((len (lst acc)
                 (if (null lst)
                     acc
                     (len (cdr lst) (1+ acc)))))
        (len lst 0)))
或者更准确的说，局部函数(local function) len是尾递归调用，因为在递归调用返回时没有什么其他
的事情发生了。和length/r不同的是，它不是在递归回溯的时候构建返回值而是在递归调用的过程中积累返回值。
所以额外的acc参数，在最后一层递归调用结束后就可以简单的返回。

好的编译器可以将一个尾调用编译成一个goto，因此可以将一个尾递归函数编译成一个loop。在典型的机器语言代码中(machine language code)，
当第一次执行到表示len的指令片段(the segment of instructions)时，栈上会有信息指示在返回时该怎么做。
由于在尾递归调用后没有残余的事情要做，这个信息对于第二次调用仍然是有效的：我们从第二次调用返回后需要做的仅仅就是从第一次调用返回。
因此，在设置了参数的新值后我们就可以跳到函数的开头，然后就像做第二次调用一样动作。但实际上没有函数调用发生。

另一个利用函数调用抽象(abstraction of function calls)而又没有开销的方法是使函数内联编译(compiled inline)。
针对调用的开销比函数体执行代价还高的小型函数来说这非常有价值。例如，下面的代码判断是否是仅含有一个元素的列表::
   (declaim (inline single?))
   (defun single? (lst)
      (and (consp lst) (null (cdr lst))))
因为这个函数是在全局被声明为内联的，引用了single?的函数在编译后将不需要真正的函数调用.[2]_ 如果我们定义一个调用它的函数,
::
  (defun foo (x)
     (single? (bar x)))
当foo被编译后，single?函数体中的代码将会被编译进foo的函数体，就好像我们直接些
::
  (defun foo (x)
     (let ((lst (bar x)))
       (and (consp lst) (null (cdr lst)))))

.. [2] 为了让内联声明(inline declaration)有效，你同时必须设置编译参数，告诉它你想获得最快的代码。

内联编译(inline compilation)有两个限制。递归函数不能内联。另外如果一个内联函数被重新定义，我们就必须
重新编译调用它的任何函数，否则调用仍然使用原来的定义。

在一些Lisp早期方言中，有些使用宏(macros) (Section 10.2) 来避免函数调用。在Common Lisp中通常认为这是没有必要的。

不同的Lisp编译器做的优化也千差万别。如果你想了解你的编译器为某个函数生成的代码，试着调用disassemble。
该函数接受一个函数或者函数名并显示它编译后的形式(compiled form)。即便你看到的东西是完全无法理解的，
你仍然可以使用disassemble来判断声明是否起效果：编译函数的两个版本，一个使用声明一个不使用，
然后观察由disassemble显示的两组代码之间是否有差异。你也可以用类似的技巧来查看函数是否被内联编译了。
不管那种情况，确保事先设置编译参数来获得最快的代码。
   

13.3 类型声明 (Type Declarations)
================================

13.4 避免垃圾 (Garbage Avoidance)
===================================================

13.5 示例: 池 (Example: Pools)
=======================================

13.6 快速操作符 (Fast Operators)
=======================================

13.7 二阶段开发 (Two-Phase Development)
==================================================

Chapter 13 总结 (Summary)
============================

Chapter 13 练习 (Exercises)
==================================
