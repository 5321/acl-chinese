Chapter 3 列表 (Lists)
**********************************

列表是 Lisp 中基本的数据结构之一。在最早的 Lisp 方言中，他们是唯一的数据结构： Lisp 这个名字本来代表的是 "LISt Processor" 。但 Lisp 已经超越这个缩写很久了。 Common Lisp 是一个有着各式各样数据结构的通用性程式语言(general-purpose programming language)。

Lisp 程序开发通常呼应着开发 Lisp 语言自身。在最初版本的 Lisp 程序，你可能使用很多列表。然而之后的版本，你可能换到快速、特定的数据结构。本章描述了你可以用列表所做的很多事情，以​​及使用它们来演示一些普遍的 Lisp 概念。

3.1 构建 (Conses)
====================

在2.4节我们介绍了 ``cons`` , ``car`` , 以及 ``cdr`` ，基本的 List 操作函数 (list-manipulation fuctions)。 ``cons`` 真正所做的事情是，把两个对象结合成到一个有两部分的对象，称之为 *cons* 对象。概念上来说，一个 cons 是一对指针; 第一个是car ，第二个是cdr。

Cons 对象提供了一个方便的表示法来表示任何类型的对象。一个 cons 里的一对指针可以指向任何类型的对象，包括 cons 对象。它利用到我们之后可以用 ``cons`` 来构建列表的可能性。

我们往往不会把列表想成是成对的，但它们可以这样被定义。任何非空的列表，都可以被视为一对由列表第一个元素及列表其余元素所组成的。 Lisp 列表体现了这个概念。我们使用 cons 的一半来指向列表的第一个元素，然后用另一半指向列表其余的元素(可能是别的 cons 或nil)。 Lisp 的惯例是使用 ``car`` 代表列表的第一个元素，而用 ``cdr`` 代表列表的其余的元素。所以现在 ``car`` 是列表的第一个元素的同义词，而 ``cdr`` 是列表的其余的元素的同义词。列表不是不同的对象，而是像 cons 这样的方式连结起来。

当我们想在 ``NIL`` 上面建立东西时，

::

   > (setf x (cons 'a nil))
   (A)

\

.. figure:: https://dl-web.dropbox.com/get/Juanito/acl-images/Figure-3.1.png?w=903fbe8f
    
图3.1 一个元素的列表

产生的列表由一个cons 所组成，见图3.1。这种表达 cons 的方式叫做箱子标示法(box notation)，因为每一个 cons 是用一个箱子表示，内含指向 ``car`` 和 ``cdr`` 的指针。当我们呼叫 ``car`` 与``cdr``时，我们得到指针指向的地方：

::
   
   > (car x)
   A
   > (cdr x)
   NIL

当我们构建一个多元素的列表时，我们得到一串 conses ：

::

   > (setf y (list 'a 'b 'c))
   (A B C)

产生的结构见图3.2。现在当我们问这个列表的 ``cdr`` 是什么，它是一个两个元素的列表。

\

.. figure:: https://dl-web.dropbox.com/get/Juanito/acl-images/Figure-3.2.png?w=b42e4db9
   
图3.2 三个元素的列表

::

   > (cdr y)
   (B C)

在一个有多个元素的列表中， ``car`` 指针让你取得元素，而 ``cdr`` 让你取得列表内其余的东西。

一个列表可以有任何类型的对象作为元素，包括另一个列表：

::

   > (setf z (list 'a (list 'b 'c) 'd'))
   (A (B C) D)

这种情况发生时，它的结构如图3.3所示; 第二个 cons 的 ``car`` 指针也指向一个列表：

::

  > (car (cdr z))
  (B C)

\

.. figure:: https://dl-web.dropbox.com/get/Juanito/acl-images/Figure-3.3.png?w=10d193e0
    
图3.3 嵌套列表


前两个我们构建的列表都有三个元素; 只不过 ``z`` 列表的第二个元素也刚好是一个列表。像这样的列表称为 *嵌套* 列表，而像 ``y`` 这样的列表称之为 *平坦* 列表( *flat* list)。

如果自变量是一个 cons，函数 ``consp`` 回传真。所以我们可以这样定义 ``listp`` ：

::

  (defun our-listp (x)
  (or (null x) (consp x)))

因为所有不是 cons 的东西就是一个原子(atom)，判断式 ``atom`` 可以这样定义：

::

   (defun our-atom (x) (not (consp x)))

注意， ``NIL`` 是一个原子，同时也是一个列表。

3.2 等式 (Equality)
=====================

3.3 为什么Lisp没有指针 (Why Lisp Has No Pointers)
=======================================================

3.4 建立列表 (Building Lists)
=================================

3.5 示例：压缩 (Example: Compression)
============================================

3.6 存取 (Access)
======================

3.7 映成函数 (Mapping Functions)
============================================

3.8 树 (Trees)
======================

3.9 理解递归 (Understanding Recursion)
============================================

3.10 集合 (Sets)
======================

3.11 序列 (Sequences)
=================================

3.12 栈 (Stacks)
=================================

3.13 点列表 (Dotted Lists)
=================================

3.14 关连列表 (Assoc-lists)
===================================

3.15 示例：最短路径 (Example: Shortest Path)
==================================================

3.16 垃圾 (Garbages)
=========================

Chapter 3 总结 (Summary)
================================

Chapter 3 习题 (Exercises)
==================================