Chapter 3 列表 (Lists)
**********************************

列表是 Lisp 中基本的数据结构之一。在最早的 Lisp 方言中，他们是唯一的数据结构： Lisp 这个名字本来代表的是 "LISt Processor" 。但 Lisp 已经超越这个缩写很久了。 Common Lisp 是一个有着各式各样数据结构的通用性程式语言(general-purpose programming language)。

Lisp 程序开发通常呼应着开发 Lisp 语言自身。在最初版本的 Lisp 程序，你可能使用很多列表。然而之后的版本，你可能换到快速、特定的数据结构。本章描述了你可以用列表所做的很多事情，以​​及使用它们来演示一些普遍的 Lisp 概念。

3.1 构建 (Conses)
====================

在2.4节我们介绍了 ``cons`` , ``car`` , 以及 ``cdr`` ，基本的 List 操作函数 (list-manipulation fuctions)。 ``cons`` 真正所做的事情是，把两个对象结合成一个有两部分的对象，称之为 *Cons* 对象。概念上来说，一个 cons 是一对指针; 第一个是car ，第二个是cdr。

Cons 对象提供了一个方便的表示法来表示任何类型的对象。一个 Cons 对象里的一对指针可以指向任何类型的对象，包括 Cons 对象本身。它利用到我们之后可以用 ``cons`` 来构建列表的可能性。

我们往往不会把列表想成是成对的，但它们可以这样被定义。任何非空的列表，都可以被视为一对由列表第一个元素及列表其余元素所组成的列表。 Lisp 列表体现了这个概念。我们使用 cons 的一半来指向列表的第一个元素，然后用另一半指向列表其余的元素(可能是别的 Cons 或nil)。 Lisp 的惯例是使用 ``car`` 代表列表的第一个元素，而用 ``cdr`` 代表列表的其余的元素。所以现在 ``car`` 是列表的第一个元素的同义词，而 ``cdr`` 是列表的其余的元素的同义词。列表不是不同的对象，而是像 Cons 这样的方式连结起来。

当我们想在 ``NIL`` 上面建立东西时，

::

   > (setf x (cons 'a nil))
   (A)

\

.. figure:: https://dl-web.dropbox.com/get/Juanito/acl-images/Figure-3.1.png?w=903fbe8f
    
图3.1 一个元素的列表

产生的列表由一个 Cons 所组成，见图3.1。这种表达 Cons 的方式叫做箱子标示法 (box notation)，因为每一个 Cons 是用一个箱子表示，内含一个 ``car`` 和 ``cdr`` 的指针。当我们调用 ``car`` 与 ``cdr`` 时，我们得到指针指向的地方：

::
   
   > (car x)
   A
   > (cdr x)
   NIL

当我们构建一个多元素的列表时，我们得到一串 Conses (a chain of conses) ：

::

   > (setf y (list 'a 'b 'c))
   (A B C)

产生的结构见图3.2。现在当我们想得到这个列表的 ``cdr`` 时，它是一个两个元素的列表。

\

.. figure:: https://dl-web.dropbox.com/get/Juanito/acl-images/Figure-3.2.png?w=b42e4db9
   
图3.2 三个元素的列表

::

   > (cdr y)
   (B C)

在一个有多个元素的列表中， ``car`` 指针让你取得元素，而 ``cdr`` 让你取得列表内其余的东西。

一个列表可以有任何类型的对象作为元素，包括另一个列表：

::

   > (setf z (list 'a (list 'b 'c) 'd'))
   (A (B C) D)

当这种情况发生时，它的结构如图3.3所示; 第二个 Cons 的 ``car`` 指针也指向一个列表：

::

  > (car (cdr z))
  (B C)

\

.. figure:: https://dl-web.dropbox.com/get/Juanito/acl-images/Figure-3.3.png?w=10d193e0
    
图3.3 嵌套列表


前两个我们构建的列表都有三个元素; 只不过 ``z`` 列表的第二个元素也刚好是一个列表。像这样的列表称为 *嵌套* 列表，而像 ``y`` 这样的列表称之为 *平坦* 列表( *flat* list)。

如果自变量是一个 Cons 对象，函数 ``consp`` 回传真。所以我们可以这样定义 ``listp`` ：

::

  (defun our-listp (x)
  (or (null x) (consp x)))

因为所有不是 Cons 对象的东西就是一个原子 (atom)，判断式 ``atom`` 可以这样定义：

::

   (defun our-atom (x) (not (consp x)))

注意， ``NIL`` 是一个原子，同时也是一个列表。

3.2 等式 (Equality)
=====================

每一次你调用 ``cons`` 时， Lisp 会配置一块新的内存给两个指针。所以如果我们用同样的自变量调用 ``cons`` 两次，我们得到两个数值看起来一样，但实际上是两个不同的对象：

::

   > (eql (cons 'a nil) (cons 'a nil))
   NIL

如果我们也可以询问两个列表是否有相同元素，那就很方便了。 Common Lisp 提供了这种目的另一个判断式： ``equal`` 。而另一方面 ``eql`` 只有在它的自变量是相同对象时才回传真，

::

   > (setf x (cons 'a nil))
   (A)
   > (eql x x)
   T
  
本质上``equal`` 若它的自变量打印出的值相同时，回传真：

::

   > (equal x (cons 'a nil))
   T

这个判断式对非列表结构​​的别种对象也有效，但一种仅对列表有效的版本可以这样定义：

::

   > (defun our-equal (x y)
       (or (eql x y)
           (and (consp x)
                (consp y)
                (our-equal (car x) (car y))
                (our-equal (cdr x) (cdr y)))))

这个定义意味着，如果某个 x 和 y 相等( ``eql`` )，那么他们也相等( ``equal`` )。

3.3 为什么Lisp没有指针 (Why Lisp Has No Pointers)
=======================================================

一个理解 Lisp 的秘密之一是意识到变量是有值的，就像列表有元素一样。如同 Conses 对象有指针指向他们的元素，变量有指针指向他们的值。

你可能在别的语言中使用过显示指针 (explicitly pointer)。在 Lisp ，你永远不用这么做，因为语言帮你处理好指针了。我们已经在列表看过这是怎么实现的。同样的事情发生在变量身上。举例来说，假设我们想要把两个变量设成同样的列表：

::

    > (setf x '(a b c))
   (A B C)
   > (setf y x)
   (A B C)

.. figure:: https://dl-web.dropbox.com/get/Juanito/acl-images/Figure-3.4.png?w=72840b32
    
图 3.4 两个变量设为相同的列表

当我们把 x 的值 赋给 y 时，究竟发生什么事呢？内存中与 x 有关的位置并没有包含这个列表，而是一个指针指向它。当我们给 y 赋一个相同的值时， Lisp 复制的是指针，而不是列表。（图 3.4 显示赋值 x 给y 后的结果）所以无论何时你把一个变量赋给另一个变量时，两个变量会有 `` eql`` 的值。

:: 

   > (eql x y)
   T

Lisp 没有指针的原因是因为每一个值，其实概念上来说都是一个指针。当你赋一个值给变量或将这个值存在数据结构中，其实被储 存的是指向这个值的指针。当你要取得变量的值，或是存在数据结构中的内容时， Lisp 返回指向这个值的指针。但这都在台面下发生。你可以不加思索地把值放在结构里，或放 "在" 变量里。

为了效率的原因， Lisp  有时会选择一个折衷的表示法，而不是指针。举例来说，因为一个小整数所需的内存空间，少于一个指针所需的空间，一个 Lisp 实现可能会直接处理这个小整数，而不是用指针来处理。但基本要点是，程序员，预设你可以把任何东西放在任何地方。除非你声明你不愿这么做，不然你能够在任何的资料结构，存放任何类型的对象，包括结构本身。

3.4 建立列表 (Building Lists)
=================================

3.5 示例：压缩 (Example: Compression)
============================================

3.6 存取 (Access)
======================

3.7 映成函数 (Mapping Functions)
============================================

3.8 树 (Trees)
======================

3.9 理解递归 (Understanding Recursion)
============================================

3.10 集合 (Sets)
======================

3.11 序列 (Sequences)
=================================

3.12 栈 (Stacks)
=================================

3.13 点列表 (Dotted Lists)
=================================

3.14 关连列表 (Assoc-lists)
===================================

3.15 示例：最短路径 (Example: Shortest Path)
==================================================

3.16 垃圾 (Garbages)
=========================

Chapter 3 总结 (Summary)
================================

Chapter 3 习题 (Exercises)
==================================