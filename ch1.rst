第一章：簡介
************

\ `約翰麥卡錫 <http://zh.wikipedia.org/wiki/%E7%BA%A6%E7%BF%B0%C2%B7%E9%BA%A6%E5%8D%A1%E9%94%A1>`_\ (John McCarthy)和他的學生於1958年開始Lisp的初次實現工作。Lisp是繼FORTRAN之後，仍在使用的最古老的程式語言。更值得注意的是，它仍走在程式語言技術的最前面。懂Lisp的程式設計師會告訴你，有某種東西使Lisp與眾不同。

Lisp與眾不同的部分原因是它被設計成能夠自己進化。你能用Lisp定義新的Lisp運算元。當新的抽象概念風行時（如物件導向程式設計），我們總是發現在Lisp是最容易來實現的。這樣的基因深植在Lisp當中，永遠不會過時。
 
1.1. 新的工具
===================

為什麼要學Lisp？ 因為它讓你能做一些其它語言做不到的事情。如果你只想寫一個函數來回傳小於 \ ``n``\  的數字總和，那麼用Lisp和C是差不多的：

::

	; Lisp                   /* C */
	(defun sum (n)           int sum(int n){
	  (let ((s 0))             int i, s = 0;
	    (dotimes (i n s)       for(i = 0; i < n; i++)
	      (incf s i))))          s += i;
	                            return(s);
	                          }

如果你只想做這種簡單的事情，那用什麼語言都不重要。假設你想寫一個函數，輸入一個數 \ ``n``\  ，回傳把 \ ``n``\  與傳入引數相加的函數。

:: 

	; Lisp 
	(defun addn (n)
	  #'(lambda (x)
	      (+ x n)))

在C語言中 \ ``addn``\  怎麼實現？你根本寫不出來。

你可能會想，誰想做這樣的事情？程式語言教你不要做它們沒有提供的事情。你得用程式語言的思維來寫程式，而且想得到你所不能描述的東西是很困難的。當我剛開始寫程式時─用Baisc─我不知道有遞迴，因為我根本不知道有這個東西。我是用Basic在思考。我只能用疊代的概念表達算法，所以我怎會知道遞迴呢？

如果你不知道\ `詞法閉包 <http://zh.wikipedia.org/zh-tw/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)>`_ \ (上述 \ ``addn``\  的範例)，相信我，Lisp程式設計師一直使用它。很難找到任何長度的Common Lisp程式沒有使用閉包的好處。在112頁前，你自己會持續使用它。

閉包僅是其中一個我們在別的語言找不到的抽象概念之一。另一個更有價值的Lisp特質是，Lisp程序是用Lisp的資料結構來表示的。這表示你可以寫出會寫程式的程式。人們真的需要這個嗎？沒錯─它們叫做巨集，有經驗的程式設計師也一直在使用它。到173頁你就可以自己寫出自己的巨集了。

有了巨集、閉包以及執行期型態，Lisp凌駕在物件導向程式設計之上。如果你了解上面那句話，也許你不應該閱讀此書。你得充分了解Lisp才知道為什麼此言不虛。但這不是空泛之言。這是一個重要的論點，而在17章用程式相當明確的證明了這點。

第二章到第十三章會循序漸進地介紹所有你為了理解17章程式的概念。你的努力會有所回報：你會感到在C++寫程式是窒礙難行的，就像有經驗的C++程式設計師用Basic寫程式會感到窒息一樣。更加鼓舞人心的是，如果我們思考為什麼會有這種感覺。Basic對於用C++寫程式是令人感到窒息的是因為有經驗的C++程式設計師知道一些用Basic不可能表達出來的技術。同樣地，學習Lisp不僅教你學會一門新的語言─它教你新的和更強大的思考程式的方法。

1.2. 新的技術
===================

如上一節所提到的，Lisp給你別的語言所不能提供的工具。但更多的是，獨立地說，伴隨Lisp的新特性─自動記憶體管理，類別型別，閉包，等等─每一項都使寫程式變得如此簡單。結合起來，它們組成了一個關鍵的部分使得一種新的寫程式的方式是有可能的。

Lisp被設計為可擴展的：它讓你定義自己的運算元。這是可能的，因為Lisp是由和你的程式一樣的函數與巨集所構成的。所以擴展Lisp就和寫一個Lisp程式一樣簡單。事實上，它是如此的容易（和有用）以至於擴展語言自身成了標準實踐。當你在用Lisp語言寫程式時，你也在創造一個適合你的程式的語言。你由下而上地，也由上而下地工作。

幾乎所有的程式都可以從訂作適合自己所需的語言中受益。然而越複雜的程式，由下而上的程式設計就顯得越有價值。一個由下而上所設計出來的程式可寫成一系列的層，每層擔任上一層的程式語言。\ `TeX <http://en.wikipedia.org/wiki/TeX>`_\ 是最早使用這種方法所寫的程式之一。你可以用任何語言由下而上地設計程式，但Lisp是本質上最適合這種方法的工具。

由下而上地程式設計自然地導出可擴展的軟體。如果你把由下而上地程序設計的原則想成你程式的最上層，那這層就成為使用者的程式語言。因為可擴展的思想深植於Lisp當中，使得Lisp成為實現可擴展軟體的理想語言。三個1980年代最成功的程式提供了Lisp作為擴展自身的語言：\ `GNU Emacs <http://www.gnu.org/software/emacs/>`_\ ，\ `Autocad <http://www.autodesk.com.tw/adsk/servlet/pc/index?siteID=1170616&id=14977606>`_\ ，和\ `Interleaf <http://en.wikipedia.org/wiki/Interleaf>`_\ 。

由下而上也是得到可重複使用軟體的最好方法。寫可重用軟體的本質是把共同的地方從細節中分離出來，而由下而上地程式設計方法本質地創造這種分離。與其努力撰寫一個龐大的應用，不如努力創造一個語言，用相對小的努力在這語言上撰寫你的應用。和應用相關的特性集中在最上層，以下的層可以組成一個適合這種應用的語言─還有什麼比程式語言更具可重用性的呢？

Lisp讓你不僅寫出更複雜的程式，而且寫的更快。Lisp程式通常很簡短─Lisp給了你更高的抽象化，所以你不用寫太多程式。就像\ `Frederick Brooks <http://en.wikipedia.org/wiki/Fred_Brooks>`_ 所指出的，寫程式所花的時間主要取決於程式的長度。因此這個單獨的事實意味者用Lisp寫程式所花的時間較少。這種效果被Lisp的動態特質放大了：在Lisp中，編輯-編譯-測試循環短到使寫程式像是即時的。

更高的抽象化與互動的環境能改變各個機構開發軟體的方式。術語\ *快速建型*\ 描述了一種由Lisp而開始的寫程式方法：在Lisp，你可以用比寫規格說明更短的時間寫出一個原型來，而這種原型是高度抽象化的，可作為一個比用英語所寫的更好的規格說明。而且Lisp讓你可以輕易的從原型轉成產品軟體。當寫一個考慮到速度的Common Lisp程序時，透過現代編譯器的編譯，它們和用其他的高階語言寫的程式執行得一樣快。

除非你相當熟悉Lisp，這個簡介像是無意義和冠冕堂皇的聲明。\ *Lisp凌駕物件導向程式設計？*\ *你創造適合你程式的語言？*\ *用Lisp寫程式是即時的？*\ 這些說法是什麼意思？現在這些說法就像是空淡的湖泊。隨著你學到更多實際的Lisp特色，見過更多可執行的程式，它們就會被實際經驗之水所充滿，而有了明確的形狀。

1.3. 新的方法
===================

本書的目標之一是不光是解釋Lisp語言，而是一種由Lisp創造的新的寫程式方法成為可能。這是一種你在將來會見得更多的方法。隨著程式環境變得更強大，程式語言變得更抽象，Lisp的寫程式風格正逐漸取代舊的\ *規劃-然後-實現*\ 的模式。

在舊的模式中，錯誤永遠不應出現。事前辛苦訂出縝密的規格說明，來保證程式完美的執行。理論上聽起來不錯。不幸地，規格說明是人寫的，也是人來實現的。實際上結果是，\ *規劃-然後-實現*\ 模型不太有效。

身為 OS/360 的專案經理，\ `Frederick Brooks <http://en.wikipedia.org/wiki/Fred_Brooks>`_ 非常熟悉這種傳統的模式。他也非常熟悉它的後果：

  任何 OS/360 的用戶很快的意識到它應該做得更好...再者，產品延期，用了更多的記憶體，成本是估計的好幾倍，效能一直不好，直到第一版後的好幾個版本更新才可以。

而這描述了那個時代最成功系統之一。

舊模式的問題是它忽略了人的局限性。在舊模式中，你打賭規格說明是不會有嚴重的缺失，實現它們是把規格轉成程式的簡單事情。經驗顯示這實在是非常壞的賭注。打賭規格說明是誤導的，程式到處都是臭蟲會更保險一點。

這其實就是新的寫程式模式所假設的。設法盡量降低錯誤的成本，而不是希望人們不犯錯。錯誤的成本是修補它所花的時間。使用強大的語言跟好的程式環境，這種成本會大幅地降低。編程風格可以更多地依靠探索，較少地依靠計畫。

規劃是一種必要之惡。它是對風險的反應：越是危險，預先規劃顯得更重要。強大的工具降低風險，也降低了規劃的需求。程式的設計可以從最有用的消息來源中受益：曾實現它的經驗。

Lisp風格從1960年代一直朝著這個方向演進。你在Lisp中可以如此快速地寫出原型，以致於你能經過好幾個設計和實現的循環，而在舊的模式當中，你可能才剛寫完規格說明。你不用擔心設計的缺失，因為你更快地發現它們。你也不用擔心那麼多臭蟲。當你用函數式風格來寫程式，你的臭蟲只有局部的影響。當你使用一種很抽象的語言，某些臭蟲(如\ `迷途指針 <http://zh.wikipedia.org/zh-tw/%E8%BF%B7%E9%80%94%E6%8C%87%E9%92%88>`_\ )不再可能發生，而剩下的臭蟲很容易找出，因為你的程式更短了。當你有一個互動的環境，你可以即時修補臭蟲，不必經歷編輯，編譯，測試的漫長過程。

Lisp風格會這麼演進式因為它產生的結果。聽起來很奇怪，少的計畫意味著更好的設計。技術史上相似的例子不勝枚舉。一個相似的改變發生在十五世紀的繪畫圈裡。在油畫流行前，畫家使用一種叫做\ `蛋彩 <http://zh.wikipedia.org/zh-tw/%E8%9B%8B%E5%BD%A9%E7%95%AB>`_\ 的材料來作畫。蛋彩不能被混和或塗掉。犯錯的代價非常高，也使得畫家變得保守。後來隨著油畫顏料的出現，作畫風格有了大幅地改變。油畫\ "允許你再來一次" 這對困難主題的處理，像是畫人體，提供了決定性的有利條件。

新的材料不僅使畫家更容易作畫了。它使新的更大膽的作畫方式成為可能。Janson寫道：

  如果沒有油畫顏料，佛萊明大師們的可見現實的征服的口號就會大打折扣。於是，從技術的角度來說，也是如此，但他們當之無愧地稱得上是"現代繪畫之父"，油畫顏料從此以後成為畫家的基本顏料。

做為一種介質，蛋彩與油畫顏料一樣美麗。但油畫顏料的彈性給想像力更大的空間─這是決定性的因素。

程式設計正經歷著相同的改變。新的介質像是 "動態的物件導向語言"──即 Lisp。這不是說我們所有的軟體在幾年內都要用Lisp來寫。從蛋彩到油畫的轉變也不是一夜完成的; 油彩一開始只在領先的藝術中心流行，而且經常混合著蛋彩來使用。我們現在似乎正處於這個階段。Lisp被大學，研究室和某些頂尖的公司所使用。同時，從Lisp借鑑的思想越來越多地出現在主流語言中：交互式開發環境，\ `垃圾回收 <http://zh.wikipedia.org/zh-tw/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)>`_\，執行期類別，僅舉其中幾個。

強大的工具正降低探索的風險。這對程式設計師來說是好消息，因為意味者我們可以從事更有野心的專案。油畫的確有這個效果。採用油畫後的時期正是繪畫的黃金時期。類似的跡象正在程式設計的領域中發生。
