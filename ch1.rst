第一章：簡介
************

\ `約翰麥卡錫 <http://zh.wikipedia.org/wiki/%E7%BA%A6%E7%BF%B0%C2%B7%E9%BA%A6%E5%8D%A1%E9%94%A1>`_\ (John McCarthy)和他的學生於1958年開始Lisp的初次實現工作。Lisp是繼FORTRAN之後，仍在使用的最古老的程式語言。更值得注意的是，它仍走在程式語言技術的最前面。懂Lisp的程式設計師會告訴你，有某種東西使Lisp與眾不同。

Lisp與眾不同的部分原因是它被設計成能夠自己進化。你能用Lisp定義新的Lisp運算元。當新的抽象概念風行時（如物件導向程式設計），我們總是發現在Lisp是最容易來實現的。這樣的基因深植在Lisp當中，永遠不會過時。
 
1.1. 新的工具
===================

為什麼要學Lisp？ 因為它讓你能做一些其它語言做不到的事情。如果你只想寫一個函數來回傳小於\ ``n``\ 的數字總和，那麼用Lisp和C是差不多的：

::

	; Lisp                   /* C */
	(defun sum (n)           int sum(int n){
	  (let ((s 0))             int i, s = 0;
	    (dotimes (i n s)       for(i = 0; i < n; i++)
	      (incf s i))))          s += i;
	                            return(s);
	                          }

如果你只想做這種簡單的事情，那用什麼語言都不重要。假設你想寫一個函數，輸入一個數\ ``n``\ ，回傳把\ ``n``\ 與傳入引數相加的函數。

:: 

	; Lisp 
	(defun addn (n)
	  #'(lambda (x)
	      (+ x n)))

在C語言中\ ``addn``\ 怎麼實現？你根本寫不出來。

你可能會想，誰想做這樣的事情？程式語言教你不要做它們沒有提供的事情。你得用程式語言的思維來寫程式，而且想得到你所不能描述的東西是很困難的。當我剛開始寫程式時─用Baisc─我不知道有遞迴，因為我根本不知道有這個東西。我是用Basic在思考。我只能用疊代的概念表達算法，所以我怎會知道遞迴呢？

如果你不知道\ `詞法閉包 <http://zh.wikipedia.org/zh-tw/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)>`_ \ (上述addn的範例)，相信我，Lisp程式設計師一直使用它。很難找到任何長度的Common Lisp程式沒有使用閉包的好處。在112頁前，你自己會持續使用它。

閉包僅是其中一個我們在別的語言找不到的抽象概念之一。另一個更有價值的Lisp特質是，Lisp程序是用Lisp的資料結構來表示的。這表示你可以寫出會寫程式的程式。人們真的需要這個嗎？沒錯─它們叫做巨集，有經驗的程式設計師也一直在使用它。到173頁你就可以自己寫出自己的巨集了。

有了巨集、閉包以及執行期型態，Lisp凌駕在物件導向程式設計之上。如果你了解上面那句話，也許你不應該閱讀此書。你得充分了解Lisp才知道為什麼此言不虛。但這不是空泛之言。這是一個重要的論點，而在17章用程式相當明確的證明了這點。

第二章到第十三章會循序漸進地介紹所有你為了理解17章程式的概念。\ [你的努力會有所回報]_\ ：你會感到在C++寫程式是窒礙難行的，就像有經驗的C++程式設計師用Basic寫程式會感到窒息一樣。更加鼓舞人心的是，如果我們思考為什麼會有這種感覺。Basic對於用C++寫程式是令人感到窒息的是因為有經驗的C++程式設計師知道一些用Basic不可能表達出來的技術。同樣地，學習Lisp不僅教你學會一門新的語言─它教你新的和更強大的思考程式的方法。

.. [你的努力會有所回報] The reward for you will be an equivocal one:


1.2. 新的技術
===================

如上一節所提到的，Lisp給你別的語言所不能提供的工具。但更多的是，獨立地說，伴隨Lisp的新特性─自動記憶體管理，類別型別，閉包，等等─每一項都使寫程式變得如此簡單。結合起來，它們組成了一個關鍵的部分使得一種新的寫程式的方式是有可能的。

Lisp被設計為可擴展的：它讓你定義自己的運算元。這是可能的，因為Lisp是由和你的程式一樣的函數與宏所構成的。所以擴展Lisp就和寫一個Lisp程式一樣簡單。事實上，它是如此的容易（和有用）以至於擴展語言自身成了標準實踐。當你在用Lisp語言寫程式時，你也在創造一個適合你的程式的語言。你由下而上地，也由上而下地工作。

幾乎所有的程式都可以從訂作適合自己所需的語言中受益。然而越複雜的程式，由下而上的程式設計就顯得越有價值。一個由下而上所設計出來的程式可寫成一系列的層，每層擔任上一層的程式語言。TeX是最早使用這種方法所寫的程式之一。你可以用任何語言由下而上地設計程式，但Lisp是本質上最適合這種方法的工具。

由下而上地程式設計自然地導出可擴展的軟體。如果你把由下而上地程序設計的原則想成你程式的最上層，那這層就成為使用者的程式語言。因為可擴展的思想深植於Lisp當中，使得Lisp成為實現可擴展軟體的理想語言。三個1980年代最成功的程式提供了Lisp作為擴展自身的語言：GNU Emacs，Autocad，和Interleaf

由下而上也是得到可重複使用軟體的最好方法。寫可重用軟體的本質是把共同的地方從細節中分離出來，而由下而上地程式設計方法本質地創造這種分離。與其努力撰寫一個龐大的應用，不如努力創造一個語言，用相對小的努力在這語言上撰寫你的應用。和應用相關的特性集中在最上層，以下的層可以組成一個適合這種應用的語言─還有什麼比程式語言更具可重用性的呢？

Lisp讓你不僅寫出更複雜的程式，而且寫的更多。Lisp程式通常很簡短─Lisp給了你更大的概念，所以你不用寫太多程式。就像\ `Frederick Brooks <http://en.wikipedia.org/wiki/Fred_Brooks>`_ 所指出的，寫程式所花的時間主要取決於它的長度。因此這個單獨的事實意味者用Lisp寫程式所花的時間較少。這種效果被Lisp的動態特質放大：在Lisp中，編輯-編譯-測試循環短到使編程像是即時的。

更高的抽象與互動的環境能改變各個機構開發軟體的方式。術語*快速建型*描述了一種由Lisp而開始的寫程式方法：在Lisp，你可以用比寫規格說明更短的時間寫出一個原型來，而這種原型是高度抽象化的，可作為一個比用英語所寫的更好的規格說明。而且Lisp讓你可以輕易的從原型轉成產品軟體。當寫一個考慮到速度的Common Lisp程序時，透過現代編譯器的編譯，它們和用其他的高階語言寫的程式執行得一樣快。

除非你相當熟悉Lisp，這個簡介像是無意義和冠冕堂皇的聲明。\ *Lisp凌駕物件導向程式？*\ *你創造適合你程式的語言？*\ *用Lisp寫程式是即時的？*\ 這些說法是什麼意思？現在這些說法就像是空淡的湖泊。隨著你學到更多實際的Lisp特色，見過更多可行的程式，它們就會被實際經驗之水所充滿，而有了明確的形狀。

1.3. 新的方法
===================
