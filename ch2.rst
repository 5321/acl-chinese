Chapter 2 歡迎來到Lisp (Welcome to Lisp)
****************************************************

本章的目的是儘快讓你開始寫程式。本章結束時，你會掌握足夠的 Common Lisp 知識來撰寫程式。

2.1 形式 (Form)
=======================

你可以經由使用 Lisp 而學習它，這是千真萬確的事實，因為 Lisp 是互動式語言。任何 Lisp 系統都包含一個互動式的前台叫做 *頂層* (toplevel)。你在頂層輸入 Lisp 表達式 (expression)，然後系統顯示它們的值。

Lisp 通常顯示一個符號告訴你，它正在等待你的輸入。許多 Common Lisp 的實現用  ``>``  作為頂層提示符 (prompt)。我們在這也用這符號。

最簡單的 Lisp 表達式之一是一個整數。如果我們在提示符後面輸入  ``1``  ，

::

   > 1
   1
   >

系統會印出它的值，伴隨著另一個提示符，告訴你它在等待更多的輸入。

這種情況下，顯示的值和我們輸入的值一樣。一個數字 1 稱之為對自身求值。當我們輸入需要做某些計算來求值的表達式時，生活變得更加有趣了。舉例來說，如果我們想把兩個數相加，我們輸入類似：

::

   > (+ 2 3)
   5

在表達式  ``(+ 2 3)``  中，  ``+``  稱作運算元，而數字 2 跟 3 稱之為引數 (arguments)。

在日常生活中，我們會把此表達式寫作  ``2 + 3``  ，但在 Lisp 我們把  ``+``  運算元寫在前面，後面跟著引數，把整個表達式用一對括號包起來：  ``(+ 2 3)``  。這稱之為  *前序*  表達式。一開始可能覺得這樣寫表達式有點怪，但事實上這種表示法是 Lisp 最好的東西之一。

舉例來說，我們想要把三個數加起來，用通常的表示法我們要寫兩次  ``+``  ，

::

   2 + 3 + 4

然而在 Lisp 中我們只需增加一個引數：

::

   (+ 2 3 4)

平常我們用  ``+``  ，它必須有兩個引數，一個在左，一個在右。前序表示法的彈性意味者，在 Lisp 中，  ``+``  可以接受任意數目的引數，包括沒有引數：

::

   > (+)
   0
   > (+ 2)
   2
   > (+ 2 3)
   5
   > (+ 2 3 4)
   9
   > (+ 2 3 4 5)
   14

因為運算元可以接受不同數目的引數，我們需要用括號，來註明表達式的開始和結束。

可以是巢狀表達式。即表達式中的引數，可以是另一個複雜的表達式：

::

   > (/ (- 7 1) (- 4 2))
   3

用中文來說， (七減一) 除以 (四減二) 。

另一個 Lisp 表示法美麗的地方是：它就是這麼簡單。所有 Lisp 表達式要嘛是  ``1``  這樣的原子 (atom)，或是包在括號中，由零個或多個表達式組成的列表 (lists)。以下是合法的 Lisp 表達式：

::

   2     (+ 2 3)     (+ 2 3 4)     (/ (- 7 1) (- 4 2))

我們將看到，所有的 Lisp 程式都採用這種形式。像 C 這種語言有更複雜的語法：算數表達式採用中序表示法; 函數呼叫採用某種前序表示法，引數用逗號隔開; 表達式用分號隔開; 而一段程式用大括號隔開。

在 Lisp 中，我們用單一的表示法來表達所有的概念。

2.2 求值 (Evaluation)
========================

上一小節中，我們在頂層輸入表達式，然後 Lisp 顯示它們的值。在這節裡我們深入理解一下表達式是如何被求值的。

在 Lisp 中，  ``+``  是一個函數，然而一個表達式如  ``(+ 2 3)``  是一個函數呼叫。

當 Lisp 對函數呼叫求值時，它做這兩個步驟：

  1. 首先先對引數從左至右求值。在這個情況是，每一個引數對自身求值，所以引數的值分別是  ``2``  跟  ``3``  。
  2. 引數的值傳入以運算元命名的函數。在這個情況是，即  ``+``  函數，返回  ``5``  。
  
  如果任何引數本身是函數呼叫，它們遵循上述規則。所以當  ``(/ (- 7 1) (- 4 2))``  被求值時所發生的情況：

  1. Lisp 對  ``(- 7 1)``  求值: 7 求值為 7， 1 求值為 1，它們被傳給函數  ``-``  ，返回 6。
  2. Lisp 對  ``(- 4 2)``  求值: 4 求值為 4， 2 求值為 2，它們被傳給函數  ``-``  ，返回 2。
  3. 數值 6 與 2 被傳入函數  ``/``  ，返回 3。

不是所有的 Common Lisp 運算元都是函數，但大部分是。而函數呼叫都是照這樣來求值的。對引數從左至右求值，然後將它們的數值傳入函數，再返回整個表達式的值。這稱為 Common Lisp 的求值規則。

:: 

   逃離麻煩

   如果你試著輸入 Lisp 不能理解的東西，它會顯示一個錯誤訊息，然後把你帶到 *中斷迴圈* (break loop)。
   中斷迴圈給予有經驗的程式設計師一個機會來找出錯誤的原因，不過最初你只會想知道如何從中斷迴圈中跳出。
   如何返回頂層取決於你所使用的 Common Lisp 實現。在這個假設的實現環境中，輸入 :abort 跳出：

   > (/ 1 0)
   Error: Division by zero
          Options: :abort, :backtrace
   >> :abort
   >
   
   附錄A 告訴你如何對 Lisp 程式除錯，以及給出一些常見的錯誤例子。

一個運算元不遵守 Common Lisp 求值規則是  ``quote``  。這  ``quote``  叫做特殊運算元，意味者他有自己特別的求值規則。而這個規則是：什麼也不做。這  ``quote``  運算元接受一個引數，然後逐字地返回它。

::

   > (quote (+ 3 5))
   (+ 3 5)

方便起見，Common Lisp 定義  ``'``  作為  ``quote``  的縮寫。你可以在任何表達式前貼上一個  ``'``  得到與呼叫  ``quote``  同樣的效果：

::

   > '(+ 3 5)
   (+ 3 5)

使用縮寫  ``'``  比  ``quote``  來得普遍。Lisp 提供  ``quote``  作為一種 *保護* 表達式被求值的方式。下一節會解釋為什麼這種保護很有用。

2.3 資料 (Data)
==================

Lisp 提供我們所有其他語言有的資料型別，和一些其他語言所沒有的。有一個我們已經使用的型別是 *整數* (integer)，它用一系列的數字來表示：  ``256``  。另一種與別的語言一樣的資料型別是 *字串* (string)，它用一系列被雙引號夾住的字元表示：  ``ora et labora`` [#]_  。整數與字串都是對自身求值的。

.. [#] 是拉丁文，意思是禱告與工作。 

我們通常在別的語言找不到的兩個 Lisp 資料型別是 *符號* (symbol) 與 *列表* (lists)， *符號* 是單字 (words)。無論你怎麼輸入，通常它們被轉換成大寫：

::

   > 'Artichoke
   ARTICHOKE

符號（通常）不對自身求值，因此若你想引用一個符號，你應該像上例那樣  ``'``  引用它。

*列表* 是由被括號包住的零個或多個元素來表示。元素可以是任何型別，包括列表。你必須引用表(  ``'``  )，不然 Lisp 會以為這是一個函數呼叫：

::

   > '(my 3 "Sons")
   (MY 3 SONS)
   > '(the list (a b c) has 3 elements)
   (THE LIST (A B C) HAS 3 ELEMENTS)
   
注意一個引號，保護整個表達式以及裡面的表達式被求值。

你可以呼叫  ``list``  來創建列表。因為  ``list``  是一個函數，它的引數會被求值。這裡我們看一個在函數  ``list``  呼叫裡面呼叫  ``+``  函數的例子。

::

   > (list 'my (+ 2 1) "Sons")
   (MY 3 "Sons")

我們現在來到領悟 Lisp 最卓越的特性之一的地方。  *Lisp 的程式用列表來表示*  (  *Lisp programs are expressed by lists*  )。如果引數的優雅與彈性不能說服你 Lisp 表示法是一個無價的工具，這裡應該能使你信服。這意味著 Lisp 程式可以寫出 Lisp 程式。 Lisp 程式設計師能（並且經常）寫出能為自己寫程式的程式。

到第10章我們才來考慮這種程式，但在現在了解列表和表達式的關係是非常重要的，而不是被它們搞混。這也就是為什麼我們需要  ``quote``  。如果一個列表被引用了，則求值規則對列表自身來求值; 如果沒有被引用，則列表被視為是程式，依求值規則對列表求值後，回傳它的值。

::

   > (list '(+ 2 1) (+ 2 1))
   ((+ 2 1) (3))

這裡第一個引數被引用了，所以產生一個列表。第二個引數沒有被引用，視為函數呼叫，經求值後得到一個數字。

在 Common Lisp 中有兩種方法來表示空的列表。你可以用一對不包括任何東西的括號來表示，或用符號  ``nil``  來表示空表。你用哪種表示法來表示空表都沒關係，但它會被顯示為  ``nil``  ：

::
   
   > ()
   NIL
   > nil
   NIL

你不需要引用  ``nil``  (但引用也無妨)，因為  ``nil``  是對自身求值的。


2.4 列表運算 (List Operations)
====================================

用函數  ``cons``  來創建列表。如果傳入的第二個引數是一個列表，則返回一個由第二個引數所組成的新列表，其中新列表的第一個元素是傳入的第一個引數：

::

   > (cons 'a '(b c d))
   (A B C D)

我們可以把新元素建立在空表之上來創建新列表。上一節所看到的函數  ``list``  只是一個把幾個元素加到  ``nil``  上的快捷方式：

::

   > (cons 'a '(cons 'b nil))
   (A B)
   > (list a b)
   (A B)

來取出列表元素的基本函數是  ``car``  和  ``cdr``  。列表的  ``car``  是第一個元素，而列表的  ``cdr``  是第一個元素之後的所有元素：

::

   > (car '(a b c))
   A
   > (cdr '(a b c))
   (B C)

你可以把  ``car``  與  ``cdr``  混合使用來取得列表中的任何元素。如果我們想要取得第三個元素，我們可以：

::

   > (car (cdr (cdr '(a b c d))))
   C

不過，你可以用更簡單的  ``third``  來做到同樣的事情：

::

   > (third '(a b c d))
   C

2.5 真與假 (Truth)
===========================

在 Common Lisp 中，符號  ``t``  是表示  ``真``  的預設值。和  ``nil``  一樣，  ``t``  也是對自身求值的。如果引數是一個列表，則函數  ``listp``  返回  ``真``  ：

:: 
   
   > (listp '(a b c))
   T

一個函數的回傳值被解釋成  ``真``  或  ``假``  ，則此函數被稱為判斷式 (  *predicate*  )。 Common Lisp 中，判斷式的名字通常以  ``p``  結尾。

``假``  在 Common Lisp 中，用  ``nil``  ，空表來表示。如果我們傳給  ``listp``  的引數不是列表，則回傳  ``nil``  。

::

   > (listp 27)
   NIL

因為  ``nil``  在 Common Lisp 中扮演兩個角色，如果引數是一個空表，則函數  ``null``  回傳  ``真``  。

::

   > (null nil)
   T
   
而如果引數是  ``假``  ，則函數  ``not``  回傳  ``真``  ：

::

  > (not nil)
  T

``null``  與  ``nil``  做的是一樣的事情。

在 Common Lisp 中，最簡單的條件式是  ``if``  。它通常接受三個引數：一個  *test*  表達式，一個  *then*  表達式和一個  *else*  表達式。  ``test``  表達式被求值。若為  ``真``  ，則  ``then``  表達式被求值，並回傳這個值。若  ``test``  表達式為  ``假``  ，則  ``else``  表達式被求值，並回傳這個值：

::

   > (if (listp '(a b c))
         (+ 1 2)
         (+ 5 6))
   3
   > (if (listp 27)
         (+ 1 2)
         (+ 5 6))
   11

跟  ``quote``  一樣，  ``if``  是特殊運算元。不能用一個函數來實現，因為函數呼叫的引數永遠會被求值，而  ``if``  的特點是只有最後兩個引數的其中一個會被求值。  ``if``  的最後一個引數是選擇性的。如果你忽略它，預設是  ``nil``  ：

::

   > (if (listp 27)
         (+ 1 2))
   NIL

雖然  ``t``  是  ``真``  的預設表示法，任何不是  ``nil``  的東西，在邏輯的語意中被認為是  ``真``  。

::

   > (if 27 1 2)
   1

邏輯運算元  **and**  和  **or**  與條件式 (conditionals)類似。兩者都接受任意數目的引數，但只對能夠決定回傳值的那幾個引數來作求值。如果所有的引數都為  ``真``  （即不為  ``nil``  )，那麼  ``and``  會返回最後一個引數的值：

::

   > (and t (+ 1 2))
   3

如果其中一個引數為  ``假``  ，那麼之後的所有引數都不會被求值。  ``or``  也是如此，只要碰到一個是  ``真``  的引數，就停止對之後的所有的引數求值。

這兩個運算元稱之為  *巨集*  。跟特殊運算元一樣，巨集可以繞過一般的求值規則。第十章解釋了如何撰寫你自己的巨集。

2.6 函數 (Functions)
===========================

你可以用  ``defun``  來定義新函數。它通常接受三個以上的引數：一個名字，一列參數 (a list of parameters)，及組成函數主體的一個或多個表達式。我們可能會這樣定義  ``third``  ：

::

   > (defun our-third (x)
       (car (cdr (cdr x))))
   OUR-THIRD

第一個引數說明此函數的名稱將是 our-third。第二個引數，一個列表 (x)，說明這個函數會接受一個參數 (parameter): x 。這樣使用的占位符 (placeholder) 符號叫做  *變量*  。當變量代表了傳入函數的引數，如這裡的 x ，又被叫做  *參數*  ( *parameter* )。

定義的其它部分，  ``(car (cdr (cdr x)))``  ，即所謂的函數主體 (the body of the function)。它告訴 Lisp 怎麼計算此函數的回傳值。所以，呼叫一個  ``our-third``  函數，對於我們作為引數傳入的任何 x，會回傳  ``(car (cdr (cdr x)))``  ：

::

   > (our-third '(a b c d))
   C

既然我們已經看過了變量，就更簡單來了解什麼是符號了。它們是變量的名字，它們本身就是以物件的方式存在。這也是為什麼符號，像列表一樣必須被引用。一個列表必須被引用，不然會被當做程式。一個符號必須要被引用，不然會被當做變量。

你可以把函數定義想成廣義版的 Lisp 表達式。下面的表達式測試 1 和 4 的和是否大於 3 ：

::

   > (> (+ 1 4) 3)
   T

藉由替換這些數字為變量，我們可以寫一個函數，測試任兩數之和是否大於第三個數：

::

   > (defun sum-greater (x y z)
       (> (+ x y) z))
   SUM-GREATER
   > (sum-greater 1 4 3)
   T

Lisp 不對程式、過程 (procedure)及函數來作區別。函數作了所有的事情（事實上，函數是語言的主要部分）。如果你想要把你的函數之一當作是主函數 ( *main* function)，可以這麼做，但你平常就能在頂層中調用任何一個函數。這表示當你寫程式時，你可以把程式分成一小塊一小塊地來作測試。

2.7 遞迴 (Recursion)
===========================

2.8 閱讀Lisp (Reading Lisp)
==============================

2.9 輸入輸出 (Input and Output)
================================

2.10 變數 (Variables)
===================================

2.11 賦值 (Assignment)
================================

2.12 函數式程式設計 (Functional Programming)
=============================================

2.13 疊代 (Iteration)
=========================

2.14 函數作為物件 (Functions as Objects)
==========================================

2.15 型別 (Types)
=========================

2.16 展望 (Looking Forward)
==================================

Chapter 2 總結 (Summary)
================================

Chapter 2 練習 (Exercises)
==================================