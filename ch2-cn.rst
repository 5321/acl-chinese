Chapter 2 欢迎来到Lisp (Welcome to Lisp)
**************************************************

本章的目的是尽快让你开始编程。本章结束时，你会掌握足够的 Common Lisp 知识来编程。

2.1 形式 (Form)
===================

你可以经由编写 Lisp 而学习它，这是千真万确的事实，因为 Lisp 是交互式语言。任何 Lisp 系统都包含一个交互式的前端叫做 *顶层* (toplevel)。你在顶层输入 Lisp 表达式 (expression)，然后系统显示它们的值。

Lisp 通常显示一个符号告诉你，它正在等待你的输入。许多 Common Lisp 的实现用  ``>``  作为顶层提示符 (prompt)。我们在这也用这符号。

最简单的 Lisp 表达式之一是一个整数。如果我们在提示符后面输入  ``1``  ，

::

   > 1
   1
   >

系统会打印出它的值，伴随着另一个提示符，告诉你它在等待更多的输入。

这种情况下，显示的值和我们输入的值一样。一个数字 1 称之为对自身求值。当我们输入需要做某些计算来求值的表达式时，生活变得更加有趣了。举例来说，如果我们想把两个数相加，我们输入类似：

::

   > (+ 2 3)
   5

在表达式  ``(+ 2 3)``  中，  ``+``  称作操作符，而数字 2 跟 3 称之为自变量 (arguments)。

在日常生活中，我们会把此表达​​式写作  ``2 + 3``  ，但在 Lisp 我们把  ``+``  操作符写在前面，后面跟着自变量，把整个表达式用一对括号包起来：  ``(+ 2 3)``  。这称之为 *前序* 表达式。一开始可能觉得这样写表达式有点怪，但事实上这种表示法是 Lisp 最好的东西之一。

举例来说，我们想要把三个数加起来，用通常的表示法我们要写两次  ``+``  ，

::

   2 + 3 + 4

然而在 Lisp 中我们只需增加一个自变量：

::

   (+ 2 3 4)

平常我们用  ``+``  ，它必须有两个自变量，一个在左，一个在右。前序表示法的弹性意味者，在 Lisp 中，  ``+``  可以接受任意数目的自变量，包括没有自变量：

::

   > (+)
   0
   > (+ 2)
   2
   > (+ 2 3)
   5
   > (+ 2 3 4)
   9
   > (+ 2 3 4 5)
   14

因为操作符可以接受不同数目的自变量，我们需要用括号，来注明表达式的开始和结束。

表达式可以嵌套。即表达式中的自变量，可以是另一个复杂的表达式：

::

   > (/ (- 7 1) (- 4 2))
   3

用中文来说， (七减一) 除以 (四减二) 。

另一个 Lisp 表示法美丽的地方是：它就是这么简单。所有 Lisp 表达式要么是  ``1``  这样的原子 (atom)，要么是包在括号中，由零个或多个表达式组成的列表 (lists)。以下是合法的 Lisp 表达式：

::

   2 (+ 2 3) (+ 2 3 4) (/ (- 7 1) (- 4 2))

我们将看到，所有的 Lisp 程序都采用这种形式。像 C 这种语言有更复杂的语法：算数表达式采用中序表示法; 函数调用采用某种前序表示法，自变量用逗号隔开; 表达式用分号隔开; 而一段程序用大括号隔开。

在 Lisp 中，我们用单一的表示法来表达所有的概念。

2.2 求值 (Evaluation)
==========================

上一小节中，我们在顶层输入表达式，然后 Lisp 显示它们的值。在这节里我们深入理解一下表达式是如何被求值的。

在 Lisp 中，  ``+``  是一个函数，然而一个表达式如  ``(+ 2 3)``  是一个函数调用。

当 Lisp 对函数调用求值时，它做这两个步骤：

  1. 首先先对自变量从左至右求值。在这个情况是，每一个自变量对自身求值，所以自变量的值分别是  ``2``  跟  ``3``  。
  2. 自变量的值传入以操作符命名的函数。在这个情况是，即  ``+``  函数，返回  ``5``  。
  
  如果任何自变量本身是函数调用，它们遵循上述规则。所以当  ``(/ (- 7 1) (- 4 2))``  被求值时所发生的情况：

  1. Lisp 对 \ ``(- 7 1)``\  求值: 7 求值为 7，1 求值为 1，它们被传给函数\ ``-``\ ，返回 6。
  2. Lisp 对 \ ``(- 4 2)``\  求值: 4 求值为 4，2 求值为 2，它们被传给函数\ ``-``\ ，返回 2。
  3. 数值 6 与 2 被传入函数  ``/``  ，返回 3。

不是所有的 Common Lisp 操作符都是函数，但大部分是。而函数调用都是照这样来求值。对自变量从左至右求值，然后将它们的数值传入函数，返回整个表达式的值。这称为 Common Lisp 的求值规则。

::

   逃离麻烦

   如果你试着输入 Lisp 不能理解的东西，它会显示一个错误讯息，然后把你带到 *中断循环* (b​​reak loop)。
   中断回圈给予有经验的程序员一个机会来找出错误的原因，不过最初你只会想知道如何从中断循环中跳出。
   如何返回顶层取决于你所使用的 Common Lisp 实现。在这个假设的实现环境中，输入 :abort 跳出：

   > (/ 1 0)
   Error: Division by zero
          Options: :abort, :backtrace
   >> :abort
   >
   
   附录A 告诉你如何对 Lisp 程式除错，以及给出一些常见的错误例子。

一个操作符不遵守 Common Lisp 求值规则是  ``quote``  。这  ``quote``  叫做特殊操作符，意味者他有自己特别的求值规则。而这个规则是：什么也不做。这  ``quote``  操作符接受一个自变量，然后逐字地返回它。

::

   > (quote (+ 3 5))
   (+ 3 5)

方便起见，Common Lisp 定义  ``'``  作为  ``quote``  的简写。你可以在任何表达式前贴上一个  ``'``  得到与调用  ``quote``  同样的效果：

::

   > '(+ 3 5)
   (+ 3 5)

使用缩写  ``'``  比  ``quote``  来得普遍。 Lisp 提供  ``quote``  作为一种  *保护*  表达式被求值的方式。下一节会解释为什么这种保护很有用。

2.3 数据 (Data)
=====================

Lisp 提供我们所有其他语言有的资料类型，和一些其他语言所没有的。有一个我们已经使用的类型是  *整数*  (integer)，它用一系列的数字来表示：  ``256``  。另一种与别的语言一样的资料类型是  *字串*  (string)，它用一系列被双引号夹住的字符表示：  ``ora et labora`` [#]_  。整数与字串都是对自身求值的。

.. [#] 是拉丁文，意思是祷告与工作。

我们通常在别的语言找不到的两个 Lisp 资料类型是  *符号*  (symbol) 与  *列表*  (lists)，  *符号*  是单词 (words)。无论你怎么输入，通常它们被转换成大写：

::

   > 'Artichoke
   ARTICHOKE

符号（通常）不对自身求值，因此若你想引用一个符号，你应该像上例那样  ``'``  引用它。

*列表*  是由被括号包住的零个或多个元素来表示。元素可以是任何类型，包括列表。你必须引用表(  ``'``  )，不然 Lisp 会以为这是一个函数调用：

::

   > '(my 3 "Sons")
   (MY 3 SONS)
   > '(the list (a b c) has 3 elements)
   (THE LIST (A B C) HAS 3 ELEMENTS)
   
注意一个引号，保护整个表达式以及里面的表达式被求值。

你可以调用  ``list``  来创造列表。因为  ``list``  是一个函数，它的自变量会被求值。这里我们看一个在函数  ``list``  调用里面调用  ``+``  函数的例子。

::

   > (list 'my (+ 2 1) "Sons")
   (MY 3 "Sons")

我们现在来到领悟 Lisp 最卓越的特性之一的地方。  *Lisp的程序用列表来表示*  (  *Lisp programs are expressed by lists*  )。如果自变量的优雅与弹性不能说服你 Lisp 表示法是一个无价的工具，这里应该能使你信服。这意味着Lisp程序可以写出Lisp代码。 Lisp 程序员能（并且经常）写出能为自己写程序的程序。

到第10章我们才来考虑这种程序，但在现在了解列表和表达式的关系是非常重要的，而不是被它们搞混。这也就是为什么我们需要  ``quote``  。如果一个列表被引用了，则求值规则对列表自身来求值; 如果没有被引用，则列表被视为是代码，依求值规则对列表求值后，返回它的值。

::

   > (list '(+ 2 1) (+ 2 1))
   ((+ 2 1) (3))

这里第一个自变量被引用了，所以产生一个列表。第二个自变量没有被引用，视为函数调用，经求值后得到一个数字。

在 Common Lisp 中有两种方法来表示空的列表。你可以用一对不包括任何东西的括号来表示，或用符号  ``nil``  来表示空表。你用哪种表示法来表示空表都没关系，但它会被显示为  ``nil``  ：

::
   
   > ()
   NIL
   > nil
   NIL

你不需要引用  ``nil``  (但引用也无妨)，因为  ``nil``  是对自身求值的。

2.4 列表操作 (List Operations)
==================================

用函数  ``cons``  来构建列表。如果传入的第二个自变量是一个列表，则返回一个由第二个自变量所组成的新列表，其中新列表的第一个元素是传入的第一个自变量：

::

   > (cons 'a '(b c d))
   (A B C D)

我们可以把新元素建立在空表之上来构建新列表。上一节所看到的函数  ``list``  只是一个把几个元素加到  ``nil``  上的快捷方式：

::

   > (cons 'a '(cons 'b nil))
   (A B)
   > (list a b)
   (A B)

来取出列表元素的基本函数是  ``car``  和  ``cdr``  。列表的  ``car``  是第一个元素，而列表的  ``cdr``  是第一个元素之后的所有元素：

::

   > (car '(a b c))
   A
   > (cdr '(a b c))
   (B C)

你可以把  ``car``  与  ``cdr``  混合使用来取得列表中的任何元素。如果我们想要取得第三个元素，我们可以：

::

   > (car (cdr (cdr '(a b c d))))
   C

不过，你可以用更简单的  ``third``  来做到同样的事情：

::

   > (third '(a b c d))
   C

2.5 真与假 (Truth)
===========================

在 Common Lisp 中，符号  ``t``  是表示  ``真``  的预设值。和  ``nil``  一样，  ``t``  也是对自身求值的。如果自变量是一个列表，则函数  ``listp``  返回  ``真``  ：

::
   
   > (listp '(a b c))
   T

一个函数的返回值被解释成  ``真``  或  ``假``  ，则此函数被称为判断式(  *predicate*  )。 Common Lisp 中，判断式的名字通常以  ``p``  结尾。

``假``  在 Common Lisp 中，用  ``nil``  ，空表来表示。如果我们传给  ``listp``  的自变量不是列表，则回传  ``nil``  。

::

   > (listp 27)
   NIL

因为  ``nil``  在 Common Lisp 中扮演两个角色，如果自变量是一个空表，则函数  ``null``  回传  ``真``  。

::

   > (null nil)
   T
   
而如果自变量是  ``假``  ，则函数  ``not`` 回传  ``真``  ：

::

  > (not nil)
  T

``null``  与  ``nil``  做的是一样的事情。

在 Common Lisp 中，最简单的条件式是  ``if``  。它通常接受三个自变量：一个  *test*  表达式，一个  *then*  表达式和一个  *else*  表达式。  ``test``  表达式被求值。若为  ``真``  ，则  ``then``  表达式被求值，并返回这个值。若  ``test``  表达式为  ``假``  ，则  ``else``  表达式被求值，并返回这个值：

::

   > (if (listp '(a b c))
         (+ 1 2)
         (+ 5 6))
   3
   > (if (listp 27)
         (+ 1 2)
         (+ 5 6))
   11

跟  ``quote``  一样，  ``if``  是特殊操作符。不能用一个函数来实现，因为函数调用的自变量永远会被求值，而  ``if``  的特点是只有最后两个自变量的其中一个会被求值。  ``if``  的最后一个自变量是选择性的。如果你忽略它，预设是  ``nil`` ：

::

   > (if (listp 27)
         (+ 1 2))
   NIL

虽然  ``t``  是  ``真``  的预设表示法，任何不是  ``nil``  的东西，在逻辑的语意中被​​认为是  ``真``  。

::

   > (if 27 1 2)
   1

逻辑操作符  **and**  和  **or**  与条件式 (conditionals)类似。两者都接受任意数目的自变量，但只对能够决定回传值的那几个自变量来作求值。如果所有的自变量都为  ``真`` （即不为  ``nil``  )，那么  ``and``  会返回最后一个自变量的值：

::

   > (and t (+ 1 2))
   3

如果其中一个自变量为  ``假``  ，那么之后的所有自变量都不会被求值。  ``or``  也是如此，只要碰到一个是  ``真``  的自变量，就停止对之后的所有的自变量求值。

这两个操作符称之为  *宏*  。跟特殊操作符一样，宏可以绕过一般的求值规则。第十章解释了如何编写你自己的宏。

2.6 函数 (Functions)
===========================

你可以用  ``defun``  来定义新函数。它通常接受三个以上的自变量：一个名字，一列参数 (a list of parameters)，及组成函数主体的一个或多个表达式。我们可能会这样定义  ``third``  ：

::

   > (defun our-third (x)
       (car (cdr (cdr x))))
   OUR-THIRD

第一个自变量说明此函数的名称将是 our-third 。第二个自变量，一个列表 (x)，说明这个函数会接受一个参数(parameter): x 。这样使用的占位符 (placeholder) 符号叫做  *变量*  。当变量代表了传入函数的引数，如这里的 x ，又被叫做 *参数*  ( *parameter* )。

定义的其它部分，  ``(car (cdr (cdr x)))``  ，即所谓的函数主体 (the body of the function)。它告诉 Lisp 怎么计算此函数的返回值。所以，调用一个  ``our-third``  函数，对于我们作为引数传入的任何x，会返回  ``(car (cdr (cdr x)))``  ：

::

   > (our-third '(a b c d))
   C

既然我们已经看过了变量，就更简单来了解什么是符号了。它们是变量的名字，它们本身就是以对象的方式存在。这也是为什么符号，像列表一样必须被引用。一个列表必须被引用，不然会被视为代码。一个符号必须要被引用，不然会被当做变量。

你可以把函数定义想成广义版的 Lisp 表达式。下面的表达式测试 1 和 4 的和是否大于 3 ：

::

   > (> (+ 1 4) 3)
   T

藉由替换这些数字为变量，我们可以写一个函数，测试任两数之和是否大于第三个数：

::

   > (defun sum-greater (x y z)
       (> (+ x y) z))
   SUM-GREATER
   > (sum-greater 1 4 3)
   T

Lisp 不对 程序、过程(procedure)及函数来作区别。函数作了所有的事情（事实上，函数是语言的主要部分）。如果你想要把你的函数之一当作是主函数(  *main*  function)，可以这么做，但你平常就能在顶层中调用任何一个函数。这表示当你写程式时，你可以把程式分成一小块一小块地来作测试。

2.7 递归 (Recursion)
===========================

2.8 阅读Lisp (Reading Lisp)
==============================

2.9 输入输出 (Input and Output)
================================

2.10 变量 (Variables)
===================================

2.11 赋值 (Assignment)
================================

2.12 函数式编程 (Functional Programming)
=============================================

2.13 迭代 (Iteration)
=========================

2.14 函数作为对象 (Functions as Objects)
==========================================

2.15 类型 (Types)
=========================

2.16 展望 (Looking Forward)
==================================

Chapter 2 总结 (Summary)
================================

Chapter 2 习题 (Exercises)
==================================