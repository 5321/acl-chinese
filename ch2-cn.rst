Chapter 2 欢迎来到Lisp (Welcome to Lisp)
**************************************************

本章的目的是尽快让你开始编程。本章结束时，你会掌握足够的 Common Lisp 知识来编程。

2.1 形式 (Form)
===================

你可以经由编写 Lisp 而学习它，这是千真万确的事实，因为 Lisp 是交互式语言。任何 Lisp 系统都包含一个交互式的前端叫做 *顶层* (toplevel)。你在顶层输入 Lisp 表达式 (expression)，然后系统显示它们的值。

Lisp 通常显示一个符号告诉你，它正在等待你的输入。许多 Common Lisp 的实现用  ``>``  作为顶层提示符 (prompt)。我们在这也用这符号。

最简单的 Lisp 表达式之一是一个整数。如果我们在提示符后面输入  ``1``  ，

::

   > 1
   1
   >

系统会打印出它的值，伴随着另一个提示符，告诉你它在等待更多的输入。

这种情况下，显示的值和我们输入的值一样。一个数字 1 称之为对自身求值。当我们输入需要做某些计算来求值的表达式时，生活变得更加有趣了。举例来说，如果我们想把两个数相加，我们输入类似：

::

   > (+ 2 3)
   5

在表达式  ``(+ 2 3)``  中，  ``+``  称作操作符，而数字 2 跟 3 称之为自变量 (arguments)。

在日常生活中，我们会把此表达​​式写作  ``2 + 3``  ，但在 Lisp 我们把  ``+``  操作符写在前面，后面跟着自变量，把整个表达式用一对括号包起来：  ``(+ 2 3)``  。这称之为 *前序* 表达式。一开始可能觉得这样写表达式有点怪，但事实上这种表示法是 Lisp 最好的东西之一。

举例来说，我们想要把三个数加起来，用通常的表示法我们要写两次  ``+``  ，

::

   2 + 3 + 4

然而在 Lisp 中我们只需增加一个自变量：

::

   (+ 2 3 4)

平常我们用  ``+``  ，它必须有两个自变量，一个在左，一个在右。前序表示法的弹性意味者，在 Lisp 中，  ``+``  可以接受任意数目的自变量，包括没有自变量：

::

   > (+)
   0
   > (+ 2)
   2
   > (+ 2 3)
   5
   > (+ 2 3 4)
   9
   > (+ 2 3 4 5)
   14

因为操作符可以接受不同数目的自变量，我们需要用括号，来注明表达式的开始和结束。

表达式可以嵌套。即表达式中的自变量，可以是另一个复杂的表达式：

::

   > (/ (- 7 1) (- 4 2))
   3

用中文来说， (七减一) 除以 (四减二) 。

另一个 Lisp 表示法美丽的地方是：它就是这么简单。所有 Lisp 表达式要么是  ``1``  这样的原子 (atom)，要么是包在括号中，由零个或多个表达式组成的列表 (lists)。以下是合法的 Lisp 表达式：

::

   2 (+ 2 3) (+ 2 3 4) (/ (- 7 1) (- 4 2))

我们将看到，所有的 Lisp 程序都采用这种形式。像 C 这种语言有更复杂的语法：算数表达式采用中序表示法; 函数调用采用某种前序表示法，自变量用逗号隔开; 表达式用分号隔开; 而一段程序用大括号隔开。

在 Lisp 中，我们用单一的表示法来表达所有的概念。

2.2 求值 (Evaluation)
==========================

上一小节中，我们在顶层输入表达式，然后 Lisp 显示它们的值。在这节里我们深入理解一下表达式是如何被求值的。

在 Lisp 中，  ``+``  是一个函数，然而一个表达式如  ``(+ 2 3)``  是一个函数调用。

当 Lisp 对函数调用求值时，它做这两个步骤：

  1. 首先先对自变量从左至右求值。在这个情况是，每一个自变量对自身求值，所以自变量的值分别是  ``2``  跟  ``3``  。
  2. 自变量的值传入以操作符命名的函数。在这个情况是，即  ``+``  函数，返回  ``5``  。
  
  如果任何自变量本身是函数调用，它们遵循上述规则。所以当  ``(/ (- 7 1) (- 4 2))``  被求值时所发生的情况：

  1. Lisp 对 \ ``(- 7 1)``\  求值: 7 求值为 7，1 求值为 1，它们被传给函数\ ``-``\ ，返回 6。
  2. Lisp 对 \ ``(- 4 2)``\  求值: 4 求值为 4，2 求值为 2，它们被传给函数\ ``-``\ ，返回 2。
  3. 数值 6 与 2 被传入函数  ``/``  ，返回 3。

不是所有的 Common Lisp 操作符都是函数，但大部分是。而函数调用都是照这样来求值。对自变量从左至右求值，然后将它们的数值传入函数，返回整个表达式的值。这称为 Common Lisp 的求值规则。

::

   逃离麻烦

   如果你试着输入 Lisp 不能理解的东西，它会显示一个错误讯息，然后把你带到 *中断循环* (b​​reak loop)。
   中断回圈给予有经验的程序员一个机会来找出错误的原因，不过最初你只会想知道如何从中断循环中跳出。
   如何返回顶层取决于你所使用的 Common Lisp 实现。在这个假设的实现环境中，输入 :abort 跳出：

   > (/ 1 0)
   Error: Division by zero
          Options: :abort, :backtrace
   >> :abort
   >
   
   附录A 告诉你如何对 Lisp 程序除错，以及给出一些常见的错误例子。

一个操作符不遵守 Common Lisp 求值规则是  ``quote``  。这  ``quote``  叫做特殊操作符，意味者他有自己特别的求值规则。而这个规则是：什么也不做。这  ``quote``  操作符接受一个自变量，然后逐字地返回它。

::

   > (quote (+ 3 5))
   (+ 3 5)

方便起见，Common Lisp 定义  ``'``  作为  ``quote``  的简写。你可以在任何表达式前贴上一个  ``'``  得到与调用  ``quote``  同样的效果：

::

   > '(+ 3 5)
   (+ 3 5)

使用缩写  ``'``  比  ``quote``  来得普遍。 Lisp 提供  ``quote``  作为一种  *保护*  表达式被求值的方式。下一节会解释为什么这种保护很有用。

2.3 数据 (Data)
=====================

Lisp 提供我们所有其他语言有的资料类型，和一些其他语言所没有的。有一个我们已经使用的类型是  *整数*  (integer)，它用一系列的数字来表示：  ``256``  。另一种与别的语言一样的资料类型是  *字串*  (string)，它用一系列被双引号夹住的字符表示：  ``ora et labora`` [#]_  。整数与字串都是对自身求值的。

.. [#] 是拉丁文，意思是祷告与工作。

我们通常在别的语言找不到的两个 Lisp 资料类型是  *符号*  (symbol) 与  *列表*  (lists)，  *符号*  是单词 (words)。无论你怎么输入，通常它们被转换成大写：

::

   > 'Artichoke
   ARTICHOKE

符号（通常）不对自身求值，因此若你想引用一个符号，你应该像上例那样  ``'``  引用它。

*列表*  是由被括号包住的零个或多个元素来表示。元素可以是任何类型，包括列表。你必须引用表(  ``'``  )，不然 Lisp 会以为这是一个函数调用：

::

   > '(my 3 "Sons")
   (MY 3 SONS)
   > '(the list (a b c) has 3 elements)
   (THE LIST (A B C) HAS 3 ELEMENTS)
   
注意一个引号，保护整个表达式以及里面的表达式被求值。

你可以调用  ``list``  来创造列表。因为  ``list``  是一个函数，它的自变量会被求值。这里我们看一个在函数  ``list``  调用里面调用  ``+``  函数的例子。

::

   > (list 'my (+ 2 1) "Sons")
   (MY 3 "Sons")

我们现在来到领悟 Lisp 最卓越的特性之一的地方。  *Lisp的程序用列表来表示*  (  *Lisp programs are expressed by lists*  )。如果自变量的优雅与弹性不能说服你 Lisp 表示法是一个无价的工具，这里应该能使你信服。这意味着Lisp程序可以写出Lisp代码。 Lisp 程序员能（并且经常）写出能为自己写程序的程序。

到第10章我们才来考虑这种程序，但在现在了解列表和表达式的关系是非常重要的，而不是被它们搞混。这也就是为什么我们需要  ``quote``  。如果一个列表被引用了，则求值规则对列表自身来求值; 如果没有被引用，则列表被视为是代码，依求值规则对列表求值后，返回它的值。

::

   > (list '(+ 2 1) (+ 2 1))
   ((+ 2 1) (3))

这里第一个自变量被引用了，所以产生一个列表。第二个自变量没有被引用，视为函数调用，经求值后得到一个数字。

在 Common Lisp 中有两种方法来表示空的列表。你可以用一对不包括任何东西的括号来表示，或用符号  ``nil``  来表示空表。你用哪种表示法来表示空表都没关系，但它会被显示为  ``nil``  ：

::
   
   > ()
   NIL
   > nil
   NIL

你不需要引用  ``nil``  (但引用也无妨)，因为  ``nil``  是对自身求值的。

2.4 列表操作 (List Operations)
==================================

用函数  ``cons``  来构建列表。如果传入的第二个自变量是一个列表，则返回一个由第二个自变量所组成的新列表，其中新列表的第一个元素是传入的第一个自变量：

::

   > (cons 'a '(b c d))
   (A B C D)

我们可以把新元素建立在空表之上来构建新列表。上一节所看到的函数  ``list``  只是一个把几个元素加到  ``nil``  上的快捷方式：

::

   > (cons 'a '(cons 'b nil))
   (A B)
   > (list a b)
   (A B)

来取出列表元素的基本函数是  ``car``  和  ``cdr``  。列表的  ``car``  是第一个元素，而列表的  ``cdr``  是第一个元素之后的所有元素：

::

   > (car '(a b c))
   A
   > (cdr '(a b c))
   (B C)

你可以把  ``car``  与  ``cdr``  混合使用来取得列表中的任何元素。如果我们想要取得第三个元素，我们可以：

::

   > (car (cdr (cdr '(a b c d))))
   C

不过，你可以用更简单的  ``third``  来做到同样的事情：

::

   > (third '(a b c d))
   C

2.5 真与假 (Truth)
===========================

在 Common Lisp 中，符号  ``t``  是表示  ``真``  的预设值。和  ``nil``  一样，  ``t``  也是对自身求值的。如果自变量是一个列表，则函数  ``listp``  返回  ``真``  ：

::
   
   > (listp '(a b c))
   T

一个函数的返回值被解释成  ``真``  或  ``假``  ，则此函数被称为判断式(  *predicate*  )。 Common Lisp 中，判断式的名字通常以  ``p``  结尾。

``假``  在 Common Lisp 中，用  ``nil``  ，空表来表示。如果我们传给  ``listp``  的自变量不是列表，则返回  ``nil``  。

::

   > (listp 27)
   NIL

因为  ``nil``  在 Common Lisp 中扮演两个角色，如果自变量是一个空表，则函数  ``null``  返回  ``真``  。

::

   > (null nil)
   T
   
而如果自变量是  ``假``  ，则函数  ``not`` 返回  ``真``  ：

::

  > (not nil)
  T

``null``  与  ``nil``  做的是一样的事情。

在 Common Lisp 中，最简单的条件式是  ``if``  。它通常接受三个自变量：一个  *test*  表达式，一个  *then*  表达式和一个  *else*  表达式。  ``test``  表达式被求值。若为  ``真``  ，则  ``then``  表达式被求值，并返回这个值。若  ``test``  表达式为  ``假``  ，则  ``else``  表达式被求值，并返回这个值：

::

   > (if (listp '(a b c))
         (+ 1 2)
         (+ 5 6))
   3
   > (if (listp 27)
         (+ 1 2)
         (+ 5 6))
   11

跟  ``quote``  一样，  ``if``  是特殊操作符。不能用一个函数来实现，因为函数调用的自变量永远会被求值，而  ``if``  的特点是只有最后两个自变量的其中一个会被求值。  ``if``  的最后一个自变量是选择性的。如果你忽略它，预设是  ``nil`` ：

::

   > (if (listp 27)
         (+ 1 2))
   NIL

虽然  ``t``  是  ``真``  的预设表示法，任何不是  ``nil``  的东西，在逻辑的语意中被​​认为是  ``真``  。

::

   > (if 27 1 2)
   1

逻辑操作符  **and**  和  **or**  与条件式 (conditionals)类似。两者都接受任意数目的自变量，但只对能够决定返回值的那几个自变量来作求值。如果所有的自变量都为  ``真`` （即不为  ``nil``  )，那么  ``and``  会返回最后一个自变量的值：

::

   > (and t (+ 1 2))
   3

如果其中一个自变量为  ``假``  ，那么之后的所有自变量都不会被求值。  ``or``  也是如此，只要碰到一个是  ``真``  的自变量，就停止对之后的所有的自变量求值。

这两个操作符称之为  *宏*  。跟特殊操作符一样，宏可以绕过一般的求值规则。第十章解释了如何编写你自己的宏。

2.6 函数 (Functions)
===========================

你可以用  ``defun``  来定义新函数。它通常接受三个以上的自变量：一个名字，一列参数 (a list of parameters)，及组成函数主体的一个或多个表达式。我们可能会这样定义  ``third``  ：

::

   > (defun our-third (x)
       (car (cdr (cdr x))))
   OUR-THIRD

第一个自变量说明此函数的名称将是 our-third 。第二个自变量，一个列表 (x)，说明这个函数会接受一个参数(parameter): x 。这样使用的占位符 (placeholder) 符号叫做  *变量*  。当变量代表了传入函数的自变量，如这里的 x ，又被叫做 *参数*  ( *parameter* )。

定义的其它部分，  ``(car (cdr (cdr x)))``  ，即所谓的函数主体 (the body of the function)。它告诉 Lisp 怎么计算此函数的返回值。所以，调用一个  ``our-third``  函数，对于我们作为自变量传入的任何x，会返回  ``(car (cdr (cdr x)))``  ：

::

   > (our-third '(a b c d))
   C

既然我们已经看过了变量，就更简单来了解什么是符号了。它们是变量的名字，它们本身就是以对象的方式存在。这也是为什么符号，像列表一样必须被引用。一个列表必须被引用，不然会被视为代码。一个符号必须要被引用，不然会被当做变量。

你可以把函数定义想成广义版的 Lisp 表达式。下面的表达式测试 1 和 4 的和是否大于 3 ：

::

   > (> (+ 1 4) 3)
   T

藉由替换这些数字为变量，我们可以写一个函数，测试任两数之和是否大于第三个数：

::

   > (defun sum-greater (x y z)
       (> (+ x y) z))
   SUM-GREATER
   > (sum-greater 1 4 3)
   T

Lisp 不对 程序、过程(procedure)及函数来作区别。函数作了所有的事情（事实上，函数是语言的主要部分）。如果你想要把你的函数之一当作是主函数(  *main*  function)，可以这么做，但你平常就能在顶层中调用任何一个函数。这表示当你编程时，你可以把程序分成一小块一小块地来作调试。

2.7 递归 (Recursion)
===========================

上一节我们定义的函数，调用了别的函数来帮它们做事。比如 ``sum-greater`` 调用了 ``+`` 和 ``>`` 。函数可以调用任何函数，包括自己。自己调用自己的函数叫做 *递归* (recursive)。 Common Lisp 函数 ``member`` 测试某个东西是否为一个列表的元素。下面是定义成递归函数的简化版：

::

   > (defun our-member (obj lst)
       (if (null lst)
         nil
       (if (eql (car lst) obj)
         lst
         (our-member obj (cdr lst)))))
   OUR-MEMBER

判断式 ``eql`` 测试它的两个自变量是否相同; 此外，这个定义的所有东西我们之前都学过。下面是它的运行情况：

::

   > (our-member 'b '(a b c))
   (B C)
   > (our-member 'z '(a b c))
   NIL

下面是 ``our-member`` 的定义对应到英语的描述。为了测试一个对象 ``obj`` 是否是一个列表 ``lst`` 的成员，我们

  1. 首先检查 ``lst`` 列表是否为空列表。如果是空列表，那``obj`` 一定不是它的成员，结束。
  2. 否则，若 ``obj`` 是列表的第一个元素时，它是列表的一个成员。
  3. 不然，只有当 ``obj`` 是列表其余部分的元素时，它是列表的一个成员。

当你想要了解递归函数是怎么工作时，把它翻成这样的叙述会帮助你理解。

起初，许多人觉得递归函数很难理解。大部分的理解困难来自对函数使用了一个错误的比喻。人们倾向于把函数理解为某种机器。原物料像参数 (parameters) 一样抵达; 某些工作委派给其它函数; 最后组装起来的成品，被作为一个返回值运送出去。如果我们用这种比喻来理解函数，那递归就自相矛盾了。机器怎可以把工作委派给自己？它已经在忙碌中了。

较好的比喻是，把函数想成一个处理的过程。在过程中，递归是在自然不过的事情了。我们经常在日常生活中，看到递归的过程。举例来说，假设一个历史学家，对欧洲历史上的人口变化感兴趣。研究文献的过程很可能是：

  1. 取得一个文献的复本
  2. 寻找关于人口变化的资讯
  3. 如果这份文献提到其它可能有用的文献，研究它们。

这个过程是很容易理解的，而且它是递归的，因为第三个步骤可能带出一个或多个同样的过程。

所以，别把``our-member`` 想成是一种测试某个东西是否在一个列表的机器。而是把它想成是，决定某个东西是否在一个列表的规则。如果我们从这个角度来考虑函数，那递归的矛盾就不复存在了。

2.8 阅读Lisp (Reading Lisp)
==============================

上一节我们定义的 ``our-member`` 以五个括号结尾。更复杂的函数定义可能以七、八个括号结尾。刚学 Lisp 的人看到这么多括号会感到气馁。这叫人怎么读这样的程序，更不用说编了？这叫人怎么知道哪个括号该跟哪个匹配？

答案是，你不需要这么做。 Lisp 程序员用缩排来阅读及编写程序，而不是括号。当他们在写程序时，他们让文字编辑器显示哪个括号该与哪个匹配。任一个好的文字编辑器，特别是 Lisp 系统自带的，都应该能做到括号匹配 (paren-matching)。在这种编辑器中，当你输入一个括号时，编辑器指出与其匹配的那一个。如果你的编辑器不能匹配括号，别用了，想想如何让它做到，因为没有这个功能，你根本不可能编 Lisp 程序 [1]_ 。

.. [1] 在vi，你可以用:set sm 来启用括号匹配。在Emacs，M-x lisp-mode 是一个启用的好方法。

有了好的编辑器，括号匹配不再是个问题。而且因为 Lisp 缩排有通用的惯例，阅读程序也不是个问题。因为所有人都使用一样的习惯，你可以忽略那些括号，通过缩排来阅读程序。

任何有经验的 Lisp 黑客，会发现如果是这样的 ``our-member`` 的定义很难阅读：

::
  
   (defun our-member (obj lst) (if (null lst) nil (if
   (eql (car lst) obj) lst (our-member obj (cdr lst)))))

但如果程序适当地缩排时，他就没有问题了。你可以忽略大部分的括号而仍能读懂它：

::

   defun our-member (obj lst)
     if null lst
        nil
        if eql (car lst) obj
           lst
           our-member obj (cdr lst)

事实上，这是一个你在纸上写 Lisp 程序的实用方法。等你输入的时候，可以利用编辑器匹配括号的功能。

2.9 输入输出 (Input and Output)
================================

到目前为止，我们已经利用顶层偷偷使用了 I/O​​ 。对实际的交互程序来说，这似乎还是不太够。在这一节，我们来看看几个输入输出的函数。

最普遍的 Common Lisp 输出函数是 ``format`` 。它接受两个或两个以上的自变量，第一个自变量表示，输出要在哪里被打印，第二个自变量是字串模版 (String Template)，而剩下的自变量，通常是要插入到字串模版的对象的印刷表示法 (printed representation)。下面是一个典型的例子：

::

   > (format t "~A plus ~A equals ~A. ~%" 2 3 (+ 2 3))
   2 PLUS 3 EQUALS 5
   NIL

注意到有两个东西被显示出来。第一行是 ``format`` 印出来的。第二行是调用 ``format`` 函数的返回值，就像平常顶层会打印出来的一样。通常像 ``format`` 这种函数不会直接在顶层调用，而在程序内部中使用，所以返回值不会被看到。

``format`` 的第一个自变量 ``t`` 表示输出被送到预设的地方去。通常这会是顶层。第二个自变量是一个当作输出模版的字串。在这字串里，每一个 ``~A`` 表示了被填入的位置，而 ``~%`` 表示一个换行。这些被填入的位置依序被后面的自变量替换。

标准的输入函数是 ``read`` 。当没有自变量时，它读取预设的位置，通常是顶层。下面这一个函数，提示使用者输入，并返回任何输入的东西：

::

   (defun askem (string)
     (format t "~A" string)
     (read))

   它的行为如下：

   > (askem "How old are you?")
   How old are you? 29
   29

记住 ``read`` 会一直永远等在这里，直到输入某些东西并 (通常要)按下确定 (hit return)。因此，不印出明确的提示讯息是很不明智的，否则你的程序会给人已经死机的印象，但其实它在等待输入。

第二件关于 ``read`` 需要知道的事是它很强大： ``read`` 是一个完整的 Lisp 解析器。不仅是读入字符，然后当作字串返回它们。它解析它读入的东西，并返回产生的 Lisp 对象。在上述的例子，它返回一个数字。

``askem`` 的定义虽然很短，但它显示了一些我们在之前的函数没看过的东西。它的函数主体可以有不只一个表达式。函数主体可以有任意数量的表达式。当函数被调用时，他们会依序求值，然后函数会返回最后一个的值。

在之前的每一节中，我们坚持所谓的"纯粹的" Lisp─即没有副作用的 Lisp 。一个副作用是指，一个表达式被求值的后果，对外部世界的状态作了某些改变。当我们对一个如 ``(+ 1 2)`` 这样纯粹的 Lisp 表达式求值，没有产生副作用。它只返回一个值。但当我们调用 ``format`` 时，它不仅返回值，还印出了某些东西。这是一种副作用。

当我们想要写没有副作用的程序，那么定义多个表达式的函数主体就没有意义了。最后一个表达式的值，会被当成函数的返回值，而之前表达式的值都被舍弃了。如果这些表达式没有副作用，你没有任何理由告诉lisp ，为什么要去对它们求值。

2.10 变量 (Variables)
===================================

2.11 赋值 (Assignment)
================================

2.12 函数式编程 (Functional Programming)
=============================================

2.13 迭代 (Iteration)
=========================

2.14 作为对象的函数 (Functions as Objects)
==========================================

2.15 类型 (Types)
=========================

2.16 展望 (Looking Forward)
==================================

Chapter 2 总结 (Summary)
================================

Chapter 2 习题 (Exercises)
==================================