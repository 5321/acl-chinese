第一章：简介
************

\ `约翰麦卡锡 <http://zh.wikipedia.org/zh-cn/%E7%BA%A6%E7%BF%B0%C2%B7%E9%BA%A6%E5%8D%A1%E9% 94%A1>`_\ (John McCarthy)和他的学生于1958年展开Lisp的初次实现工作。 Lisp是继FORTRAN之后，仍在使用的最古老的程序语言。更值得注意的是，它仍走在程序语言技术的最前面。懂Lisp的程序员会告诉你，有某种东西使Lisp与众不同。

Lisp与众不同的部分原因是它被设计成能够自己进化。你能用Lisp定义新的Lisp操作符。当新的抽象概念风行时（如面向对象程序设计），我们总是发现在Lisp是最容易来实现的。这样的基因深植在Lisp当中，永远不会过时。
 
1.1. 新的工具
===================

为什么要学Lisp? 因为它让你能做一些其它语言做不到的事情。如果你只想写一个函式来回传小于n的数字总和，那么用Lisp和C是差不多的：

::

	; Lisp                   /* C */
	(defun sum (n)           int sum(int n){
	  (let ((s 0))             int i, s = 0;
	    (dotimes (i n s)       for(i = 0; i < n; i++)
	      (incf s i))))          s += i;
	                            return(s);
	                          }

如果你只想做这种简单的事情，那用什么语言都不重要。假设你想写一个函式，输入一个数n，回传把n与传入参数相加的函式。

:: 

	; Lisp 
	(defun addn (n)
	  #'(lambda (x)
	      (+ x n)))

在C语言中addn怎么实现？你根本写不出来。

你可能会想，谁想做这样的事情？程序语言教你不要做它们没有提供的事情。你得用程序语言的思维来写程式，而且想得到你所不能描述的东西是很困难的。当我刚开始编程时─用Baisc─我不知道有递归，因为我根本不知道有这个东西。我是用Basic在思考。我只能用迭代的概念表达算法，所以我怎会知道递归呢？

如果你不知道\ `词法闭包 <http://zh.wikipedia.org/zh-cn/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6))>`_ \ (上述addn的范例)，相信我，Lisp程序员一直使用它。很难找到任何长度的Common Lisp程序没有使用闭包的好处。在112页前，你自己会持续使用它。

闭包仅是其中一个我们在别的语言找不到的抽象概念之一。另一个更有价值的Lisp特点是，Lisp程序是用Lisp的数据结构来表示的。这表示你可以写出会写程序的程序。人们真的需要这个吗？没错─它们叫做宏，有经验的程式设计师也一直在使用它。到173页你就可以自己写出自己的宏了。

有了宏、闭包以及运行期类别，Lisp凌驾在面向对象程序设计之上。如果你了解上面那句话，也许你不应该阅读此书。你得充分了解Lisp才知道为什么此言不虚。但这不是空泛之言。这是一个重要的论点，而在17章用程序相当明确的证明了这点。

第二章到第十三章会循序渐进地介绍所有你为了理解17章程式的概念。 \ [你的努力会有所回报]_\ ：你会感到在C++编程是窒碍难行的，就像有经验的C++程序员用Basic编程会感到窒息一样。更加鼓舞人心的是，如果我们思考为什么会有这种感觉。 Basic对于用C++编程是令人感到窒息的是因为有经验的C++程序员知道一些用Basic不可能表达出来的技术。同样地，学习Lisp不仅教你学会一门新的语言─它教你新的和更强大的思考程序的方法。

.. [你的努力会有所回报] The reward for you will be an equivocal one:

1.2. 新的技术
===================

1.3. 新的方法
===================